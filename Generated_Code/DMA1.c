/* ###################################################################
**     This component module is generated by Processor Expert. Do not modify it.
**     Filename    : DMA1.c
**     Project     : PE_Test
**     Processor   : MK70FN1M0VMJ15
**     Component   : DMAController
**     Version     : Component 01.037, Driver 01.01, CPU db: 3.00.000
**     Compiler    : GNU C Compiler
**     Date/Time   : 2019-09-02, 16:10, # CodeGen: 156
**     Abstract    :
**          This embedded component implements initialization
**          and runtime handling of an on-chip DMA controller.
**     Settings    :
**          Component name                                 : DMA1
**          Device                                         : DMA
**          Settings                                       : 
**            Minor loop mapping                           : Disabled
**            Continuous mode                              : Disabled
**            Halt on error                                : Disabled
**            Debug                                        : Disabled
**          Group arbitration type                         : Fixed
**            Group 0 priority                             : 0
**            Group 1 priority                             : 1
**          Channel arbitration type                       : Fixed
**            Autoset channel priority                     : 
**          Statically allocated channels                  : 1
**            Channel settings                             : Chan: 0, Grp: 0
**              Channel                                    : DMA_Channel0
**              Allocate channel                           : no
**              ChannelShared                              : no
**              Used by component(s)                       : DMACH1
**              Arbitration type                           : Fixed
**                Priority                                 : 0
**                Can be preempted                         : no
**                Can preempt                              : no
**              Interrupt service                          : Enabled
**                Transfer complete interrupt              : 
**                  Interrupt vector                       : INT_DMA0_DMA16
**                  Interrupt priority                     : 8
**                Error interrupt                          : 
**                  Interrupt vector                       : INT_DMA_Error
**                  Interrupt priority                     : medium priority
**          Dynamically allocatable channels               : 0
**     Contents    :
**         Init                          - LDD_TDeviceData* DMA1_Init(void);
**         InitChannel                   - LDD_TDeviceData* DMA1_InitChannel(LDD_TDeviceData *DeviceDataPtr,...
**         Enable                        - LDD_TError DMA1_Enable(DMA1_TChanDeviceData *ChanDeviceDataPtr);
**         Disable                       - LDD_TError DMA1_Disable(DMA1_TChanDeviceData *ChanDeviceDataPtr);
**         StartTransfer                 - LDD_TError DMA1_StartTransfer(DMA1_TChanDeviceData *ChanDeviceDataPtr);
**         GetTransferCompleteStatus     - bool DMA1_GetTransferCompleteStatus(DMA1_TChanDeviceData *ChanDeviceDataPtr);
**         GetError                      - LDD_DMA_TErrorFlags DMA1_GetError(DMA1_TChanDeviceData *ChanDeviceDataPtr);
**         SetSourceAddress              - LDD_TError DMA1_SetSourceAddress(DMA1_TChanDeviceData *ChanDeviceDataPtr,...
**         SetSourceTransactionSize      - LDD_TError DMA1_SetSourceTransactionSize(DMA1_TChanDeviceData...
**         SetDestinationAddress         - LDD_TError DMA1_SetDestinationAddress(DMA1_TChanDeviceData...
**         SetDestinationTransactionSize - LDD_TError DMA1_SetDestinationTransactionSize(DMA1_TChanDeviceData...
**         SetTransactionCount           - LDD_TError DMA1_SetTransactionCount(DMA1_TChanDeviceData *ChanDeviceDataPtr,...
**         SetRequestCount               - LDD_TError DMA1_SetRequestCount(DMA1_TChanDeviceData *ChanDeviceDataPtr,...
**
**     Copyright : 1997 - 2014 Freescale Semiconductor, Inc. 
**     All Rights Reserved.
**     
**     Redistribution and use in source and binary forms, with or without modification,
**     are permitted provided that the following conditions are met:
**     
**     o Redistributions of source code must retain the above copyright notice, this list
**       of conditions and the following disclaimer.
**     
**     o Redistributions in binary form must reproduce the above copyright notice, this
**       list of conditions and the following disclaimer in the documentation and/or
**       other materials provided with the distribution.
**     
**     o Neither the name of Freescale Semiconductor, Inc. nor the names of its
**       contributors may be used to endorse or promote products derived from this
**       software without specific prior written permission.
**     
**     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
**     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
**     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
**     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
**     ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
**     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
**     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
**     ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
**     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
**     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
**     
**     http: www.freescale.com
**     mail: support@freescale.com
** ###################################################################*/
/*!
** @file DMA1.c
** @version 01.01
** @brief
**          This embedded component implements initialization
**          and runtime handling of an on-chip DMA controller.
*/         
/*!
**  @addtogroup DMA1_module DMA1 module documentation
**  @{
*/         

/* MODULE DMA1. */

#include "DMA1.h"
#include "SIM_PDD.h"

/* {Default RTOS Adapter} No RTOS includes */
/* Total number of channel supported by DMA device */
#define DMA1_CHANNEL_COUNT                                  0x01U
/* Number of statically allocated DMA channels */
#define DMA1_STATIC_CHANNEL_COUNT                           0x01U
/* Number of dynamically allocated DMA channels */
#define DMA1_DYNAMIC_CHANNEL_COUNT                          0x00U

/* Logical channel constants */
#define DMA1_CHN_0_PHY_NUM                                  (0U)
#define DMA1_CHN_0_PHY_MASK                                 (1U)
#define DMA1_CHN_0_DMA_REGS_PTR                             (DMA_BASE_PTR)
#define DMA1_CHN_0_TCD_PTR                                  ((DMA1_TTCD*)(void*)&DMA_TCD0_SADDR)
#define DMA1_CHN_0_DMAMUX_CFG_REG_PTR                       ((uint8_t*)(void*)&DMAMUX0_CHCFG0)

/* Channel MUX macros */
#define DMA1__MuxReset(_DMAMUX_CFG_PTR)                     (*_DMAMUX_CFG_PTR = 0U)
#define DMA1__MuxDisableRequest(_DMAMUX_CFG_PTR)            (*_DMAMUX_CFG_PTR &= (uint8_t)~(uint8_t)DMAMUX_CHCFG_ENBL_MASK)
#define DMA1__MuxEnableRequest(_DMAMUX_CFG_PTR)             (*_DMAMUX_CFG_PTR |= DMAMUX_CHCFG_ENBL_MASK)
#define DMA1__MuxSetRequest(_DMAMUX_CFG_PTR, _REQ)          (*_DMAMUX_CFG_PTR = _REQ)

#define DMA1__CHN_ERROR_FLAGS  (DMA_ES_DBE_MASK | DMA_ES_SBE_MASK | DMA_ES_SGE_MASK | DMA_ES_NCE_MASK | \
                                        DMA_ES_DOE_MASK  | DMA_ES_DAE_MASK | DMA_ES_SOE_MASK | DMA_ES_SAE_MASK | DMA_ES_ECX_MASK)
#define DMA1__DEV_ERROR_FLAGS  (DMA_ES_CPE_MASK | DMA_ES_GPE_MASK)
/* Common macros */
#define DMA1__HaltOperations(_DmaMemMapPtr)                 (_DmaMemMapPtr->CR |= DMA_CR_HALT_MASK)
#define DMA1__ResumeOperations(_DmaMemMapPtr)               (_DmaMemMapPtr->CR &= (uint32_t)~(uint32_t)DMA_CR_HALT_MASK)
#define DMA1__CancelTransfer(_DmaMemMapPtr)                 (_DmaMemMapPtr->CR |= DMA_CR_CX_MASK)
#define DMA1__InitChannelsPriority(_DmaMemMapPtr,_ChnPriorities) (*(DMA1_TChnPriorities *)((void *)&(_DmaMemMapPtr->DCHPRI3)) = _ChnPriorities)
#define DMA1__GetErrorStatus(_DmaMemMapPtr)                 (_DmaMemMapPtr->ES)
#define DMA1__GetErrorValidFlags(_ErrorStatus)              (_ErrorStatus & DMA_ES_VLD_MASK)
#define DMA1__GetErrorFlags(_ErrorStatus)                   (_ErrorStatus & (DMA1__CHN_ERROR_FLAGS | DMA1__DEV_ERROR_FLAGS))
#define DMA1__GetChannelErrorFlags(_ErrorStatus)            (_ErrorStatus & DMA1__CHN_ERROR_FLAGS)
#define DMA1__GetDeviceErrorFlags(_ErrorStatus)             (_ErrorStatus & DMA1__DEV_ERROR_FLAGS)
#define DMA1__GetErrorChannelNumber(_ErrorStatus)           ((_ErrorStatus & DMA_ES_ERRCHN_MASK) >> DMA_ES_ERRCHN_SHIFT)

/* SW start channel macro */
#define DMA1__StartTransfer(_DmaMemMapPtr,_PhyChnNum)       (_DmaMemMapPtr->SSRT = (uint8_t)_PhyChnNum)

/* Peripheral request macros */
#define DMA1__EnableRequest(_DmaMemMapPtr,_PhyChnNum)       (_DmaMemMapPtr->SERQ = (uint8_t)_PhyChnNum)
#define DMA1__DisableRequest(_DmaMemMapPtr,_PhyChnNum)      (_DmaMemMapPtr->CERQ = (uint8_t)_PhyChnNum)
#define DMA1__DisableAllRequests(_DmaMemMapPtr)             (_DmaMemMapPtr->CERQ = (uint8_t)DMA_CERQ_CAER_MASK)

/* Error interrupts flags macros */
#define DMA1__GetChannelErrorInterruptFlag(_DmaMemMapPtr,_PhyChnMask) (_DmaMemMapPtr->ERR & _PhyChnMask)
#define DMA1__ClearChannelErrorInterruptFlag(_DmaMemMapPtr,_PhyChnNum) (_DmaMemMapPtr->CERR = (uint8_t)_PhyChnNum)
#define DMA1__ClearAllErrorInterruptFlags(_DmaMemMapPtr,_PhyChnNum) (_DmaMemMapPtr->CERR = (uint8_t)DMA_CERR_CAEI_MASK)

/* Error interrupts state macros */
#define DMA1__EnableErrorInterrupt(_DmaMemMapPtr,_PhyChnNum) (_DmaMemMapPtr->SEEI = (uint8_t)_PhyChnNum)
#define DMA1__DisableErrorInterrupt(_DmaMemMapPtr,_PhyChnNum) (_DmaMemMapPtr->CEEI = (uint8_t)_PhyChnNum)
#define DMA1__DisableAllErrorInterrupts(_DmaMemMapPtr)      (_DmaMemMapPtr->CEEI = (uint8_t)DMA_CEEI_CAEE_MASK)

/* Channel interrupt */
#define DMA1__ClearDoneFlag(_DmaMemMapPtr,_PhyChnNum)       (_DmaMemMapPtr->CDNE = (uint8_t)_PhyChnNum)
#define DMA1__ClearAllDoneFlags(_DmaMemMapPtr)              (_DmaMemMapPtr->CDNE = (uint8_t)DMA_CDNE_CAND_MASK)
#define DMA1__GetChannelInterruptFlag(_DmaMemMapPtr,_PhyChnMask) (_DmaMemMapPtr->INT & _PhyChnMask)
#define DMA1__ClearChannelInterruptFlag(_DmaMemMapPtr,_PhyChnNum) (_DmaMemMapPtr->CINT = (uint8_t)_PhyChnNum)
#define DMA1__ClearAllChannelInterruptFlags(_DmaMemMapPtr)  (_DmaMemMapPtr->CINT = (uint8_t)DMA_CINT_CAIR_MASK)

/* TCD macros */
#define DMA1__InitTCD(_TCD_PTR, _TCD)                       (*_TCD_PTR = _TCD)
#define DMA1__GetActiveFlag(_TCD_PTR)                       (_TCD_PTR->DMA_TCD_CSR_Reg & DMA_CSR_ACTIVE_MASK)
#define DMA1__GetTransferDoneFlag(_TCD_PTR)                 (_TCD_PTR->DMA_TCD_CSR_Reg & DMA_CSR_DONE_MASK)
#define DMA1__SetTransferDoneFlag(_TCD_PTR)                 (_TCD_PTR->DMA_TCD_CSR_Reg |= DMA_CSR_DONE_MASK)
#define DMA1__ClrTransferDoneFlag(_TCD_PTR)                 (_TCD_PTR->DMA_TCD_CSR_Reg &= ~(uint32_t)DMA_CSR_DONE_MASK)
#define DMA1__SetSrcDataTransferSize(_TCD_PTR, _Size)       (_TCD_PTR->DMA_TCD_ATTR_Reg = (uint16_t)((_TCD_PTR->DMA_TCD_ATTR_Reg & ~(uint32_t)DMA_ATTR_SSIZE_MASK) | (((uint32_t)(_Size)) << DMA_ATTR_SSIZE_SHIFT)))
#define DMA1__GetSrcDataTransferSize(_TCD_PTR)              ((_TCD_PTR->DMA_TCD_ATTR_Reg & DMA_ATTR_SSIZE_MASK) >> DMA_ATTR_SSIZE_SHIFT)
#define DMA1__SetDstDataTransferSize(_TCD_PTR, _Size)       (_TCD_PTR->DMA_TCD_ATTR_Reg = (uint16_t)((_TCD_PTR->DMA_TCD_ATTR_Reg & ~(uint32_t)DMA_ATTR_DSIZE_MASK) | (((uint32_t)(_Size)) << DMA_ATTR_DSIZE_SHIFT)))
#define DMA1__GetDstDataTransferSize(_TCD_PTR)              ((_TCD_PTR->DMA_TCD_ATTR_Reg & DMA_ATTR_DSIZE_MASK) >> DMA_ATTR_DSIZE_SHIFT)
#define DMA1__SetSrcAddress(_TCD_PTR, _Address)             (_TCD_PTR->DMA_TCD_SADDR_Reg = _Address)
#define DMA1__SetDstAddress(_TCD_PTR, _Address)             (_TCD_PTR->DMA_TCD_DADDR_Reg = _Address)
#define DMA1__GetSrcDstMinorLoopOffsetState(_TCD_PTR)       (_TCD_PTR->DMA_TCD_NBYTES_Reg & (DMA_NBYTES_MLOFFNO_SMLOE_MASK | DMA_NBYTES_MLOFFNO_DMLOE_MASK))
#define DMA1__SetByteCount32(_TCD_PTR, _ByteCount)          (_TCD_PTR->DMA_TCD_NBYTES_Reg = _ByteCount)
#define DMA1__SetByteCount30(_TCD_PTR, _ByteCount)          (_TCD_PTR->DMA_TCD_NBYTES_Reg =  ((_TCD_PTR->DMA_TCD_NBYTES_Reg & ~(uint32_t)DMA_NBYTES_MLOFFNO_NBYTES_MASK) | _ByteCount))
#define DMA1__SetByteCount10(_TCD_PTR, _ByteCount)          (_TCD_PTR->DMA_TCD_NBYTES_Reg =  ((_TCD_PTR->DMA_TCD_NBYTES_Reg & ~(uint32_t)DMA_NBYTES_MLOFFYES_NBYTES_MASK) | _ByteCount))
#define DMA1__GetByteCount32(_TCD_PTR)                      (uint32_t)(_TCD_PTR->DMA_TCD_NBYTES_Reg)
#define DMA1__GetByteCount30(_TCD_PTR)                      (uint32_t)(_TCD_PTR->DMA_TCD_NBYTES_Reg & DMA_NBYTES_MLOFFNO_NBYTES_MASK)
#define DMA1__GetByteCount10(_TCD_PTR)                      (uint32_t)(_TCD_PTR->DMA_TCD_NBYTES_Reg & DMA_NBYTES_MLOFFYES_NBYTES_MASK)
#define DMA1__GetMinorLoopChnLinkingState(_TCD_PTR)         (_TCD_PTR->DMA_TCD_BITER_Reg & DMA_BITER_ELINKNO_ELINK_MASK)
#define DMA1__SetBeginningMajorLoopCount9(_TCD_PTR, _RequestCount) (_TCD_PTR->DMA_TCD_BITER_Reg = (uint16_t)((_TCD_PTR->DMA_TCD_BITER_Reg & ~(uint32_t)DMA_BITER_ELINKYES_BITER_MASK) | _RequestCount))
#define DMA1__SetCurrentMajorLoopCount9(_TCD_PTR, _RequestCount) (_TCD_PTR->DMA_TCD_CITER_Reg = (uint16_t)((_TCD_PTR->DMA_TCD_CITER_Reg & ~(uint32_t)DMA_CITER_ELINKYES_CITER_MASK) | _RequestCount))
#define DMA1__SetBeginningMajorLoopCount15(_TCD_PTR, _RequestCount) (_TCD_PTR->DMA_TCD_BITER_Reg = (uint16_t)((_TCD_PTR->DMA_TCD_BITER_Reg & ~(uint32_t)DMA_BITER_ELINKNO_BITER_MASK) | _RequestCount))
#define DMA1__SetCurrentMajorLoopCount15(_TCD_PTR, _RequestCount) (_TCD_PTR->DMA_TCD_CITER_Reg = (uint16_t)((_TCD_PTR->DMA_TCD_CITER_Reg & ~(uint32_t)DMA_CITER_ELINKNO_CITER_MASK) | _RequestCount))
#define DMA1__GetBeginningMajorLoopCount9(_TCD_PTR)         (_TCD_PTR->DMA_TCD_BITER_Reg & (uint32_t)DMA_BITER_ELINKYES_BITER_MASK)
#define DMA1__GetCurrentMajorLoopCount9(_TCD_PTR)           (_TCD_PTR->DMA_TCD_CITER_Reg & (uint32_t)DMA_CITER_ELINKYES_CITER_MASK)
#define DMA1__GetBeginningMajorLoopCount15(_TCD_PTR)        (_TCD_PTR->DMA_TCD_BITER_Reg & (uint32_t)DMA_BITER_ELINKNO_BITER_MASK)
#define DMA1__GetCurrentMajorLoopCount15(_TCD_PTR)          (_TCD_PTR->DMA_TCD_CITER_Reg & (uint32_t)DMA_CITER_ELINKNO_CITER_MASK)
#define DMA1__ReadTcdBiterReg(_TCD_PTR)                     (_TCD_PTR->DMA_TCD_BITER_Reg)
#define DMA1__ReadTcdCiterReg(_TCD_PTR)                     (_TCD_PTR->DMA_TCD_CITER_Reg)

typedef struct DMA1_TChnPriorities_struct {
  uint8_t DMA1_TChnPriorities[32];                         /* Channel initial priorities */
} DMA1_TChnPriorities, * DMA1_TChnPrioritiesPtr;

/* Channel constants structure prototype */
typedef struct DMA1_TChnDevConst_struct {
  uint32_t                         PhyChnNum;              /*!< Physical channel number */
  uint32_t                         PhyChnMask;             /*!< Physical channel mask */
  DMA_MemMapPtr                    DmaMemMapPtr;           /*!< DMA registers address */
  DMA1_TTCD                       *TCDPtr;                 /*!< TCD registers address */
  uint8_t                         *DmaMuxRegPtr;           /*!< DMA mux. register address */
} DMA1_TChnDevConst, *DMA1_TChnDevConstPtr;

/* Device constants structure prototype */
typedef struct DMA1_TDevConst_struct {
  DMA1_TChnDevConst const          ChnDevConst[DMA1_CHANNEL_COUNT];
  DMA1_TChnPriorities              ChnPriorities;          /*!< Channel initial priorities */
} DMA1_TDevConst, *DMA1_TDevConstPtr;

/* Channel device data structure prototype */
typedef struct DMA1_TChnDevData_stuct {
  DMA1_TTCD                       *TCDPtr;                 /*!< Channel TCD address */
  DMA1_TChnDevConst const         *ChnDevConstPtr;         /*!< Channel device constants structure address */
  bool                             TransferCompleteStatus; /*!< Component TransferCompleteStatus variable */
  uint32_t                         RWTransactionUint;      /*!< Transaction unit size [bytes] variable */
  LDD_DMA_TErrorFlags              ErrorFlags;             /*!< Channel error flags */
  LDD_TUserData                   *UserDataPtr;            /*!< User data pointer */
  DMA1_TEvents                     Events;                 /*!< Events state variable */
  bool                             EnUser;                 /*!< Component state variable */
} DMA1_TChnDevData, *DMA1_TChnDevDataPtr;

/* Device data structure prototype */
typedef struct {
  DMA1_TChnDevData                 ChnDevData[DMA1_CHANNEL_COUNT]; /*!< Channel device data array */
} DMA1_TDeviceData, *DMA1_TDeviceDataPtr;

/* Channel constants array */
DMA1_TDevConst const DMA1_DevConst = {
  {
    { /* Channel 0 (DMA_Channel0) */
      DMA1_CHN_0_PHY_NUM,                                  /*!< Physical channel number */
      DMA1_CHN_0_PHY_MASK,                                 /*!< Physical channel mask */
      DMA1_CHN_0_DMA_REGS_PTR,                             /*!< DMA registers address */
      DMA1_CHN_0_TCD_PTR,                                  /*!< TCD registers address */
      DMA1_CHN_0_DMAMUX_CFG_REG_PTR                        /*!< Mux cfg. register address */
    }
  },
  /* Channel priorities */
  {
    {
      (DMA_DCHPRI0_GRPPRI(0x00) | DMA_DCHPRI0_CHPRI(0x03)), /* DCHPR3 register initial value */
      (DMA_DCHPRI0_GRPPRI(0x00) | DMA_DCHPRI0_CHPRI(0x02)), /* DCHPR2 register initial value */
      (DMA_DCHPRI0_GRPPRI(0x00) | DMA_DCHPRI0_CHPRI(0x01)), /* DCHPR1 register initial value */
      ( DMA_DCHPRI0_DPA_MASK |
        DMA_DCHPRI0_GRPPRI(0x00) |
        DMA_DCHPRI0_CHPRI(0x00)
      ),                               /* DCHPR0 register initial value */
      (DMA_DCHPRI0_GRPPRI(0x00) | DMA_DCHPRI0_CHPRI(0x07)), /* DCHPR7 register initial value */
      (DMA_DCHPRI0_GRPPRI(0x00) | DMA_DCHPRI0_CHPRI(0x06)), /* DCHPR6 register initial value */
      (DMA_DCHPRI0_GRPPRI(0x00) | DMA_DCHPRI0_CHPRI(0x05)), /* DCHPR5 register initial value */
      (DMA_DCHPRI0_GRPPRI(0x00) | DMA_DCHPRI0_CHPRI(0x04)), /* DCHPR4 register initial value */
      (DMA_DCHPRI0_GRPPRI(0x00) | DMA_DCHPRI0_CHPRI(0x0B)), /* DCHPR11 register initial value */
      (DMA_DCHPRI0_GRPPRI(0x00) | DMA_DCHPRI0_CHPRI(0x0A)), /* DCHPR10 register initial value */
      (DMA_DCHPRI0_GRPPRI(0x00) | DMA_DCHPRI0_CHPRI(0x09)), /* DCHPR9 register initial value */
      (DMA_DCHPRI0_GRPPRI(0x00) | DMA_DCHPRI0_CHPRI(0x08)), /* DCHPR8 register initial value */
      (DMA_DCHPRI0_GRPPRI(0x00) | DMA_DCHPRI0_CHPRI(0x0F)), /* DCHPR15 register initial value */
      (DMA_DCHPRI0_GRPPRI(0x00) | DMA_DCHPRI0_CHPRI(0x0E)), /* DCHPR14 register initial value */
      (DMA_DCHPRI0_GRPPRI(0x00) | DMA_DCHPRI0_CHPRI(0x0D)), /* DCHPR13 register initial value */
      (DMA_DCHPRI0_GRPPRI(0x00) | DMA_DCHPRI0_CHPRI(0x0C)), /* DCHPR12 register initial value */
      (DMA_DCHPRI0_GRPPRI(0x01) | DMA_DCHPRI0_CHPRI(0x03)), /* DCHPR19 register initial value */
      (DMA_DCHPRI0_GRPPRI(0x01) | DMA_DCHPRI0_CHPRI(0x02)), /* DCHPR18 register initial value */
      (DMA_DCHPRI0_GRPPRI(0x01) | DMA_DCHPRI0_CHPRI(0x01)), /* DCHPR17 register initial value */
      (DMA_DCHPRI0_GRPPRI(0x01) | DMA_DCHPRI0_CHPRI(0x00)), /* DCHPR16 register initial value */
      (DMA_DCHPRI0_GRPPRI(0x01) | DMA_DCHPRI0_CHPRI(0x07)), /* DCHPR23 register initial value */
      (DMA_DCHPRI0_GRPPRI(0x01) | DMA_DCHPRI0_CHPRI(0x06)), /* DCHPR22 register initial value */
      (DMA_DCHPRI0_GRPPRI(0x01) | DMA_DCHPRI0_CHPRI(0x05)), /* DCHPR21 register initial value */
      (DMA_DCHPRI0_GRPPRI(0x01) | DMA_DCHPRI0_CHPRI(0x04)), /* DCHPR20 register initial value */
      (DMA_DCHPRI0_GRPPRI(0x01) | DMA_DCHPRI0_CHPRI(0x0B)), /* DCHPR27 register initial value */
      (DMA_DCHPRI0_GRPPRI(0x01) | DMA_DCHPRI0_CHPRI(0x0A)), /* DCHPR26 register initial value */
      (DMA_DCHPRI0_GRPPRI(0x01) | DMA_DCHPRI0_CHPRI(0x09)), /* DCHPR25 register initial value */
      (DMA_DCHPRI0_GRPPRI(0x01) | DMA_DCHPRI0_CHPRI(0x08)), /* DCHPR24 register initial value */
      (DMA_DCHPRI0_GRPPRI(0x01) | DMA_DCHPRI0_CHPRI(0x0F)), /* DCHPR31 register initial value */
      (DMA_DCHPRI0_GRPPRI(0x01) | DMA_DCHPRI0_CHPRI(0x0E)), /* DCHPR30 register initial value */
      (DMA_DCHPRI0_GRPPRI(0x01) | DMA_DCHPRI0_CHPRI(0x0D)), /* DCHPR29 register initial value */
      (DMA_DCHPRI0_GRPPRI(0x01) | DMA_DCHPRI0_CHPRI(0x0C)) /* DCHPR28 register initial value */
    }
  }
};


/* {Default RTOS Adapter} Static object used for simulation of dynamic driver memory allocation */
static DMA1_TDeviceData DevDataPtr__DEFAULT_RTOS_ALLOC;
/* {Default RTOS Adapter} Global variable used for passing a parameter into ISR */
static DMA1_TDeviceDataPtr INT_DMA0_DMA16__DEFAULT_RTOS_ISRPARAM;
/* {Default RTOS Adapter} Global variable used for passing a parameter into ISR */
static DMA1_TDeviceDataPtr INT_DMA_Error__DEFAULT_RTOS_ISRPARAM;
static void HandleInterrupt(DMA1_TChnDevData *ChnDevDataPtr);
static uint32_t GetTransactionUnitSize(DMA1_TTCD *TCDPtr);
/*
** ===================================================================
**     Method      :  GetTransactionUnitSize (component DMAController)
**
**     Description :
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static uint32_t GetTransactionUnitSize(DMA1_TTCD *TCDPtr)
{
  uint32_t SrcTrSize = (uint32_t)1 << DMA1__GetSrcDataTransferSize(TCDPtr);
  uint32_t DstTrSize = (uint32_t)1 << DMA1__GetDstDataTransferSize(TCDPtr);

  if (SrcTrSize > DstTrSize) {
    return SrcTrSize;
  } else {
    return DstTrSize;
  }
}

/*
** ===================================================================
**     Method      :  _CancelTransfer (component DMAController)
**
**     Description :
**         CancelTransfer
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void CancelTransfer(DMA1_TChnDevConst const *ChnDevConstPtr)
{
  /* Disable new request from peripheral in DMA MUX */
  DMA1__MuxDisableRequest(ChnDevConstPtr->DmaMuxRegPtr);
  DMA1__DisableRequest(ChnDevConstPtr->DmaMemMapPtr, ChnDevConstPtr->PhyChnNum); /* Disable new request from peripheral. */
  if (DMA1__GetActiveFlag(ChnDevConstPtr->TCDPtr)) { /* Channel active? */
    DMA1__HaltOperations(ChnDevConstPtr->DmaMemMapPtr); /* Yes, stall start of any new channels */
    DMA1__CancelTransfer(ChnDevConstPtr->DmaMemMapPtr); /* Cancel current transfer */
    DMA1__ResumeOperations(ChnDevConstPtr->DmaMemMapPtr); /* Resume DMA operation */
  }
  DMA1__ClearDoneFlag(ChnDevConstPtr->DmaMemMapPtr, ChnDevConstPtr->PhyChnNum);
  DMA1__ClearChannelInterruptFlag(ChnDevConstPtr->DmaMemMapPtr, ChnDevConstPtr->PhyChnMask);
  DMA1__ClearChannelErrorInterruptFlag(ChnDevConstPtr->DmaMemMapPtr, ChnDevConstPtr->PhyChnMask);
  /* Enable new request from peripheral in DMA MUX */
  DMA1__MuxEnableRequest(ChnDevConstPtr->DmaMuxRegPtr);
}

/*
** ===================================================================
**     Method      :  DMA1_Init (component DMAController)
*/
/*!
**     @brief
**         Initializes the associated peripheral(s) and the component
**         internal variables. The method is called automatically as a
**         part of the application initialization code.
**     @return
**                         - Pointer to the device data structure. 
*/
/* ===================================================================*/
LDD_TDeviceData* DMA1_Init(void)
{
  DMA1_TDeviceData                 *DevDataPtr;            /* LDD device structure */

  /* {Default RTOS Adapter} Driver memory allocation: Dynamic allocation is simulated by a pointer to the static object */
  DevDataPtr = &DevDataPtr__DEFAULT_RTOS_ALLOC;
  /* {Default RTOS Adapter} Driver memory allocation: Fill the allocated memory by zero value */
  PE_FillMemory(DevDataPtr, 0U, sizeof(DMA1_TDeviceData));
  /* Transfer complete interrupt vector(INT_DMA0_DMA16) allocation */
  /* {Default RTOS Adapter} Set interrupt vector: IVT is static, ISR parameter is passed by the global variable */
  INT_DMA0_DMA16__DEFAULT_RTOS_ISRPARAM =  DevDataPtr;
  /* Transfer error interrupt vector(INT_DMA_Error) allocation */
  /* {Default RTOS Adapter} Set interrupt vector: IVT is static, ISR parameter is passed by the global variable */
  INT_DMA_Error__DEFAULT_RTOS_ISRPARAM =  DevDataPtr;
  /* Transfer complete interrupt vector(INT_DMA0_DMA16) priority setting */
  /* NVICIP0: PRI0=0x80 */
  NVICIP0 = NVIC_IP_PRI0(0x80);
  /* NVICISER0: SETENA|=1 */
  NVICISER0 |= NVIC_ISER_SETENA(0x01);
  /* Transfer error interrupt vector(INT_DMA_Error) priority setting */
  /* NVICIP16: PRI16=0x80 */
  NVICIP16 = NVIC_IP_PRI16(0x80);
  /* NVICISER0: SETENA|=0x00010000 */
  NVICISER0 |= NVIC_ISER_SETENA(0x00010000);
  /* Enable clock gates */
  #ifdef SIM_PDD_CLOCK_GATE_DMA
  SIM_PDD_SetClockGate(SIM_BASE_PTR, SIM_PDD_CLOCK_GATE_DMA, PDD_ENABLE);
  #endif
  #ifdef SIM_PDD_CLOCK_GATE_DMA_MULTIPLEXOR0
  SIM_PDD_SetClockGate(SIM_BASE_PTR, SIM_PDD_CLOCK_GATE_DMA_MULTIPLEXOR0, PDD_ENABLE);
  #endif
  /* Registration of the device structure */
  PE_LDD_RegisterDeviceStructure(PE_LDD_COMPONENT_DMA1_ID,DevDataPtr);
  /* Discard previous setting */
  DMA1__DisableAllRequests(DMA_BASE_PTR);                  /* Disable all request from peripheral */
  DMA1__DisableAllErrorInterrupts(DMA_BASE_PTR);           /* Disable all error interrupts */
  DMA1__CancelTransfer(DMA_BASE_PTR);                      /* Cancel transfer (if any in progress) */
  DMA1__ClearAllChannelInterruptFlags(DMA_BASE_PTR);       /* Clear all channel interrupt flags */
  DMA1__InitChannelsPriority(DMA_BASE_PTR,DMA1_DevConst.ChnPriorities); /* Initialize channel TCD (channel registers) */
  DMA_CR = (DMA_CR_GRP1PRI(0x01) | DMA_CR_GRP0PRI(0x00)); /* initialize Control register */
  return DevDataPtr;
}

/*
** ===================================================================
**     Method      :  DMA1_InitChannel (component DMAController)
*/
/*!
**     @brief
**         The method allocates DMA channel for the DMA transfer
**         defined by the transfer descriptor input parameter
**         DescriptorPtr. This method must be called before DMA channel
**         is initialized. Otherwise ERR_NOTAVAIL error code is
**         returned after call of DMA_LDD channel methods.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by [Init] method.
**     @param
**         ChIntPtr        - Pointer to a DMA transfer
**                           descriptor structure.
**     @param
**         UserDataPtr     - Pointer to the user or
**                           RTOS specific data. This pointer will be
**                           passed as an event or callback parameter.
**     @return
**                         - Error code, possible codes:
**                           - ERR_OK - OK.
**                           - ERR_SPEED - This device does not work in
**                           the active clock configuration.
**                           - ERR_DISABLED - Component or device is
**                           disabled.
**                           - ERR_NOTAVAIL - There is not any possible
**                           channel with desired features to be
**                           allocated.
*/
/* ===================================================================*/
LDD_TDeviceData* DMA1_InitChannel(LDD_TDeviceData *DeviceDataPtr, DMA1_TChnInit *ChIntPtr, LDD_TUserData *UserDataPtr)
{
  uint32_t                         LogChnNum      = ChIntPtr->ChnNum;
  DMA1_TChnDevData                *ChnDevDataPtr;
  DMA1_TChnDevConst const         *ChnDevConstPtr;
  DMA1_TTCD                       *TCDPtr;
  uint8_t                         *DmaMuxCfgPtr;

  ChnDevDataPtr  = &((DMA1_TDeviceData *)DeviceDataPtr)->ChnDevData[LogChnNum];
  ChnDevConstPtr = &(DMA1_DevConst.ChnDevConst[LogChnNum]);
  TCDPtr         = ChnDevConstPtr->TCDPtr;
  DmaMuxCfgPtr   = ChnDevConstPtr->DmaMuxRegPtr;
  DMA1__MuxReset(DmaMuxCfgPtr);                            /* Disable channel peripheral request (in the DMAMUX) */
  CancelTransfer(ChnDevConstPtr);                          /* Cancel transfer (if pending) */
  *TCDPtr = ChIntPtr->TCD;                                 /* Initialize channel TCD (channel registers) */
  ChnDevDataPtr->TransferCompleteStatus = FALSE;
  ChnDevDataPtr->ChnDevConstPtr = ChnDevConstPtr;          /* Remember channel constants address */
  ChnDevDataPtr->TCDPtr = TCDPtr;                          /* Remember channel TCD address */
  ChnDevDataPtr->UserDataPtr = UserDataPtr;                /* Remember channel User data pointer */
  ChnDevDataPtr->Events = ChIntPtr->Events;                /* Initialize events */
  DMA1__EnableErrorInterrupt(ChnDevConstPtr->DmaMemMapPtr,ChnDevConstPtr->PhyChnNum);
  ChnDevDataPtr->EnUser = ChIntPtr->EnUser;                /* Initialize channel state variable (Enabled/Disabled) */
  ChnDevDataPtr->RWTransactionUint = GetTransactionUnitSize(TCDPtr); /* Initialize RWTransactionUint variable */
  DMA1__MuxSetRequest(DmaMuxCfgPtr,ChIntPtr->MUX_CHCFG_Reg); /* Set channel peripheral request (in the DMAMUX) */
  return ChnDevDataPtr;
}

/*
** ===================================================================
**     Method      :  DMA1_Enable (component DMAController)
*/
/*!
**     @brief
**         Enables the DMATransfer component.
**     @param
**         ChanDeviceDataPtr - DMA channel
**                           data structure pointer returned by
**                           [InitChannel()] method.
**     @return
**                         - Error code, possible codes: 
**                           - ERR_OK - OK.
*/
/* ===================================================================*/
LDD_TError DMA1_Enable(DMA1_TChanDeviceData *ChanDeviceDataPtr)
{
  DMA1_TChnDevData                *ChnDevDataPtr = (DMA1_TChnDevData *)ChanDeviceDataPtr;

  ChnDevDataPtr->EnUser = TRUE;
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  DMA1_Disable (component DMAController)
*/
/*!
**     @brief
**         Disables the DMATransfer component.
**     @param
**         ChanDeviceDataPtr - DMA channel
**                           data structure pointer returned by
**                           [InitChannel()] method.
**     @return
**                         - Error code, possible codes: 
**                           - ERR_OK - OK.
*/
/* ===================================================================*/
LDD_TError DMA1_Disable(DMA1_TChanDeviceData *ChanDeviceDataPtr)
{
  DMA1_TChnDevData                *ChnDevDataPtr = (DMA1_TChnDevData *)ChanDeviceDataPtr;

  ChnDevDataPtr->EnUser = FALSE;
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  DMA1_StartTransfer (component DMAController)
*/
/*!
**     @brief
**         The method starts DMA transfer on the selected DMA channel.
**         This methods initiates explicit SW transfer request. Please
**         note that call of this method if peripheral request is
**         enabled can cause unpredictable behaviour.
**     @param
**         ChanDeviceDataPtr - DMA channel
**                           data structure pointer returned by
**                           [InitChannel()] method.
**     @return
**                         - Error code, possible codes: 
**                           - ERR_OK - OK. 
**                           - ERR_DISABLED - Component is disabled.
*/
/* ===================================================================*/
LDD_TError DMA1_StartTransfer(DMA1_TChanDeviceData *ChanDeviceDataPtr)
{
  DMA1_TChnDevData                *ChnDevDataPtr = (DMA1_TChnDevData *)ChanDeviceDataPtr;
  DMA1_TChnDevConst const         *ChnDevConstPtr = ChnDevDataPtr->ChnDevConstPtr;

  /* This test can be disabled by setting the "Ignore state checking"
     property to the "yes" value in the "Configuration inspector" */
  if (!ChnDevDataPtr->EnUser) {
    return ERR_DISABLED;
  }
  /* Start transfer */
  DMA1__StartTransfer(ChnDevConstPtr->DmaMemMapPtr, ChnDevConstPtr->PhyChnNum);
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  DMA1_GetTransferCompleteStatus (component DMAController)
*/
/*!
**     @brief
**         This method returns value of "Transfer done" flag and clears
**         this flag if it was set. It is intended to be used in
**         pooling mode to check transfer state. In this case the
**         method returns value of real hw flag.
**         It can also be used in interrupt mode. In interrupt mode the
**         method doesn't return value of real hw flag but value of sw
**         flag that is updated to the real value in the interrupt
**         service routine (This method returns FALSE unless ISR is
**         invoked).
**     @param
**         ChanDeviceDataPtr - DMA channel
**                           data structure pointer returned by
**                           [InitChannel()] method.
**     @return
**                         - Return values: 
**                           - [true] - Last transfer is done. 
**                           - [false] - Transfer is pending or last
**                           call of this method has returned [true].
*/
/* ===================================================================*/
bool DMA1_GetTransferCompleteStatus(DMA1_TChanDeviceData *ChanDeviceDataPtr)
{

  if (((DMA1_TChnDevData *)ChanDeviceDataPtr)->TransferCompleteStatus) {
    /* Clear TransferCompleteStatus */
    ((DMA1_TChnDevData *)ChanDeviceDataPtr)->TransferCompleteStatus = FALSE;
    return TRUE;
  } else {
    return FALSE;
  }
}

/*
** ===================================================================
**     Method      :  DMA1_GetError (component DMAController)
*/
/*!
**     @brief
**         Returns last recorded channel error flags.
**     @param
**         ChanDeviceDataPtr - DMA channel
**                           data structure pointer returned by
**                           [InitChannel()] method.
**     @return
**                         - DMA Error flags.
*/
/* ===================================================================*/
LDD_DMA_TErrorFlags DMA1_GetError(DMA1_TChanDeviceData *ChanDeviceDataPtr)
{
  DMA1_TChnDevData                *ChnDevDataPtr = (DMA1_TChnDevData *)ChanDeviceDataPtr;
  LDD_DMA_TErrorFlags              ErrorFlags = ChnDevDataPtr->ErrorFlags;

  ChnDevDataPtr->ErrorFlags = 0U;                          /* Clear error mask */
  return (ErrorFlags);
}

/*
** ===================================================================
**     Method      :  DMA1_SetSourceAddress (component DMAController)
*/
/*!
**     @brief
**         Sets source(read) data address.
**     @param
**         ChanDeviceDataPtr - DMA channel
**                           data structure pointer returned by
**                           [InitChannel()] method.
**     @param
**         Address         - Pointer to source data address.
**     @return
**                         - Error code, possible codes: 
**                           - ERR_OK - OK. 
**                           - ERR_DISABLED - Component is disabled. 
**                           - ERR_PARAM_ADDRESS - Source address is not
**                           multiple of DMA transaction size (byte,
**                           word, dword, ...)
*/
/* ===================================================================*/
LDD_TError DMA1_SetSourceAddress(DMA1_TChanDeviceData *ChanDeviceDataPtr, LDD_DMA_TData *Address)
{
  /* This test can be disabled by setting the "Ignore state checking"
     property to the "yes" value in the "Configuration inspector" */
  if (!((DMA1_TChnDevData *)ChanDeviceDataPtr)->EnUser) {
    return ERR_DISABLED;
  }
  /* This test can be disabled by setting the "Ignore state checking"
     property to the "yes" value in the "Configuration inspector" */
  if (((uint32_t)Address % GetTransactionUnitSize(((DMA1_TChnDevData *)ChanDeviceDataPtr)->TCDPtr)) != 0U) {
    return ERR_PARAM_ADDRESS;
  }
  DMA1__SetSrcAddress(((DMA1_TChnDevData *)ChanDeviceDataPtr)->TCDPtr, (uint32_t)Address);
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  DMA1_SetDestinationAddress (component DMAController)
*/
/*!
**     @brief
**         Sets destination(write) data address
**     @param
**         ChanDeviceDataPtr - DMA channel
**                           data structure pointer returned by
**                           [InitChannel()] method.
**     @param
**         Address         - Pointer to destination data
**                           address.
**     @return
**                         - Error code, possible codes: 
**                           - ERR_OK - OK. 
**                           - ERR_DISABLED - Component is disabled. 
**                           - ERR_PARAM_ADDRESS - Destination address
**                           is not multiple of DMA transaction size
**                           (byte, word, dword, ...)
*/
/* ===================================================================*/
LDD_TError DMA1_SetDestinationAddress(DMA1_TChanDeviceData *ChanDeviceDataPtr, LDD_DMA_TData *Address)
{
  /* This test can be disabled by setting the "Ignore state checking"
     property to the "yes" value in the "Configuration inspector" */
  if (!((DMA1_TChnDevData *)ChanDeviceDataPtr)->EnUser) {
    return ERR_DISABLED;
  }
  /* This test can be disabled by setting the "Ignore state checking"
     property to the "yes" value in the "Configuration inspector" */
  if (((uint32_t)Address % GetTransactionUnitSize(((DMA1_TChnDevData *)ChanDeviceDataPtr)->TCDPtr)) != 0U) {
    return ERR_PARAM_ADDRESS;
  }
  DMA1__SetDstAddress(((DMA1_TChnDevData *)ChanDeviceDataPtr)->TCDPtr, (uint32_t)Address);
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  DMA1_SetSourceTransactionSize (component DMAController)
*/
/*!
**     @brief
**         Sets source transaction (DMA bus-read cycle) data size.
**     @param
**         ChanDeviceDataPtr - DMA channel
**                           data structure pointer returned by
**                           [InitChannel()] method.
**     @param
**         TransactionSize - Source (bus-read)
**                           transaction data size in bytes.
**     @return
**                         - Error code, possible codes: 
**                           - ERR_OK - OK. 
**                           - ERR_DISABLED - Component is disabled. 
**                           - ERR_PARAM_SIZE - Requested transfer size
**                           is not supported by selected DMA device.
*/
/* ===================================================================*/
LDD_TError DMA1_SetSourceTransactionSize(DMA1_TChanDeviceData *ChanDeviceDataPtr, LDD_DMA_TTransactionSize TransactionSize)
{
  DMA1_TChnDevData                *ChnDevDataPtr = (DMA1_TChnDevData *)ChanDeviceDataPtr;
  DMA1_TTCD                       *TCDPtr = ChnDevDataPtr->TCDPtr;

  /* This test can be disabled by setting the "Ignore state checking"
     property to the "yes" value in the "Configuration inspector" */
  if (!ChnDevDataPtr->EnUser) {
    return ERR_DISABLED;
  }
  switch (TransactionSize) {
    case 1:
      DMA1__SetSrcDataTransferSize(TCDPtr, DMA_PDD_8_BIT);
      break;
    case 2:
      DMA1__SetSrcDataTransferSize(TCDPtr, DMA_PDD_16_BIT);
      break;
    case 4:
      DMA1__SetSrcDataTransferSize(TCDPtr, DMA_PDD_32_BIT);
      break;
    case 16:
      DMA1__SetSrcDataTransferSize(TCDPtr, DMA_PDD_16_BYTE);
      break;
    default:
      return ERR_PARAM_SIZE;
  }
  ChnDevDataPtr->RWTransactionUint = GetTransactionUnitSize(TCDPtr); /* Compute and remember new transaction unit size */
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  DMA1_SetDestinationTransactionSize (component DMAController)
*/
/*!
**     @brief
**         Sets destination transaction (DMA bus-write cycle) data size.
**     @param
**         ChanDeviceDataPtr - DMA channel
**                           data structure pointer returned by
**                           [InitChannel()] method.
**     @param
**         TransactionSize - Destination
**                           (bus-write) transaction data size in bytes.
**     @return
**                         - Error code, possible codes: 
**                           - ERR_OK - OK. 
**                           - ERR_DISABLED - Component is disabled. 
**                           - ERR_PARAM_SIZE - Requested transfer size
**                           is not supported by selected DMA device.
*/
/* ===================================================================*/
LDD_TError DMA1_SetDestinationTransactionSize(DMA1_TChanDeviceData *ChanDeviceDataPtr, LDD_DMA_TTransactionSize TransactionSize)
{
  DMA1_TChnDevData                *ChnDevDataPtr = (DMA1_TChnDevData *)ChanDeviceDataPtr;
  DMA1_TTCD                       *TCDPtr = ChnDevDataPtr->TCDPtr;

  /* This test can be disabled by setting the "Ignore state checking"
     property to the "yes" value in the "Configuration inspector" */
  if (!ChnDevDataPtr->EnUser) {
    return ERR_DISABLED;
  }
  switch (TransactionSize) {
    case 1:
      DMA1__SetDstDataTransferSize(TCDPtr, DMA_PDD_8_BIT);
      break;
    case 2:
      DMA1__SetDstDataTransferSize(TCDPtr, DMA_PDD_16_BIT);
      break;
    case 4:
      DMA1__SetDstDataTransferSize(TCDPtr, DMA_PDD_32_BIT);
      break;
    case 16:
      DMA1__SetDstDataTransferSize(TCDPtr, DMA_PDD_16_BYTE);
      break;
    default:
      return ERR_PARAM_SIZE;
  }
  ChnDevDataPtr->RWTransactionUint = GetTransactionUnitSize(TCDPtr); /* Compute and remember new transaction unit size */
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  DMA1_SetTransactionCount (component DMAController)
*/
/*!
**     @brief
**         Sets number of DMA (read/write) transactions performed after
**         next request is asserted. Please note the this value doesn't
**         represent number of transferred bytes but number on DMA
**         (read/write) transaction units.
**     @param
**         ChanDeviceDataPtr - DMA channel
**                           data structure pointer returned by
**                           [InitChannel()] method.
**     @param
**         TransactionCount - Number of R/W
**                           transaction performed after next request is
**                           asserted.
**     @return
**                         - Error code, possible codes: 
**                           - ERR_OK - OK. 
**                           - ERR_DISABLED - Component is disabled.
*/
/* ===================================================================*/
LDD_TError DMA1_SetTransactionCount(DMA1_TChanDeviceData *ChanDeviceDataPtr, LDD_DMA_TTransactionCount TransactionCount)
{
  DMA1_TChnDevData                *ChnDevDataPtr = (DMA1_TChnDevData *)ChanDeviceDataPtr;
  DMA1_TTCD                       *TCDPtr = ChnDevDataPtr->TCDPtr;

  /* This test can be disabled by setting the "Ignore state checking"
     property to the "yes" value in the "Configuration inspector" */
  if (!ChnDevDataPtr->EnUser) {
    return ERR_DISABLED;
  }
  DMA1__SetByteCount32(TCDPtr, (TransactionCount * ChnDevDataPtr->RWTransactionUint));
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  DMA1_SetRequestCount (component DMAController)
*/
/*!
**     @brief
**         Sets number of request required to complete the transfer.
**     @param
**         ChanDeviceDataPtr - DMA channel
**                           data structure pointer returned by
**                           [InitChannel()] method.
**     @param
**         RequestCount    - Number of request
**                           required to complete transfer.
**     @return
**                         - Error code, possible codes: 
**                           - ERR_OK - OK. 
**                           - ERR_DISABLED - Component is disabled.
*/
/* ===================================================================*/
LDD_TError DMA1_SetRequestCount(DMA1_TChanDeviceData *ChanDeviceDataPtr, LDD_DMA_TRequestCount RequestCount)
{
  DMA1_TChnDevData                *ChnDevDataPtr = (DMA1_TChnDevData *)ChanDeviceDataPtr;
  DMA1_TTCD                       *TCDPtr = ChnDevDataPtr->TCDPtr;

  /* This test can be disabled by setting the "Ignore state checking"
     property to the "yes" value in the "Configuration inspector" */
  if (!ChnDevDataPtr->EnUser) {
    return ERR_DISABLED;
  }
  if (DMA1__GetMinorLoopChnLinkingState(TCDPtr) != 0U) {
    DMA1__SetBeginningMajorLoopCount9(TCDPtr, RequestCount); /* Update beginning major loop count register */
    DMA1__SetCurrentMajorLoopCount9(TCDPtr, RequestCount); /* Update current major loop count register */
  } else {
    DMA1__SetBeginningMajorLoopCount15(TCDPtr, RequestCount); /* Update beginning major loop count register */
    DMA1__SetCurrentMajorLoopCount15(TCDPtr, RequestCount); /* Update current major loop count register */
  }
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  HandleInterrupt (component DMAController)
**
**     Description :
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void HandleInterrupt(DMA1_TChnDevData *ChnDevDataPtr)
{
  DMA1_TChnDevConst const         *ChnDevConstPtr = ChnDevDataPtr->ChnDevConstPtr;
  DMA_MemMapPtr                    DmaMemMapPtr = ChnDevConstPtr->DmaMemMapPtr;
  uint32_t                         ErrorStatus;

  if (DMA1__GetChannelErrorInterruptFlag(DmaMemMapPtr, ChnDevConstPtr->PhyChnMask)) {
    /* Channel error detected */
    /* Transfer error */
    ErrorStatus = DMA1__GetErrorStatus(DmaMemMapPtr);      /* Get error flags */
    if (DMA1__GetErrorValidFlags(ErrorStatus)) {           /* Any error flags valid? */
      if (DMA1__GetErrorChannelNumber(ErrorStatus) == ChnDevConstPtr->PhyChnNum) { /* Channel error flags valid? */
        /* Remember all (device and channel) error flags */
        ChnDevDataPtr->ErrorFlags |= DMA1__GetErrorFlags(ErrorStatus);
      } else {
        /* Remember device error flags only (if any flag set) */
        ChnDevDataPtr->ErrorFlags |= DMA1__GetDeviceErrorFlags(ErrorStatus);
        /* Remember channel error flags are not valid */
        ChnDevDataPtr->ErrorFlags |= LDD_DMA_UNKNOWN_ERROR;
      }
    } else {
      /* Error flags not valid */
      ChnDevDataPtr->ErrorFlags |= LDD_DMA_UNKNOWN_ERROR;
    }
    DMA1__DisableRequest(DmaMemMapPtr, ChnDevConstPtr->PhyChnNum);
    DMA1__ClearChannelErrorInterruptFlag(DmaMemMapPtr, ChnDevConstPtr->PhyChnNum);
    if (ChnDevDataPtr->Events.OnErrorFnPtr != NULL) {
      ChnDevDataPtr->Events.OnErrorFnPtr(ChnDevDataPtr->UserDataPtr);
    }
  } else if (DMA1__GetTransferDoneFlag(ChnDevConstPtr->TCDPtr)) {
    /* Transfer done without error */
    ChnDevDataPtr->TransferCompleteStatus = TRUE;
    DMA1__ClearChannelInterruptFlag(DmaMemMapPtr, ChnDevConstPtr->PhyChnNum);
    DMA1__ClearDoneFlag(DmaMemMapPtr, ChnDevConstPtr->PhyChnNum);
    if (ChnDevDataPtr->Events.OnCompleteFnPtr != NULL) {
      ChnDevDataPtr->Events.OnCompleteFnPtr(ChnDevDataPtr->UserDataPtr);
    }
  } else {
  }
}

/*
** ===================================================================
**     Method      :  DMA1_TransferComplete_ISR (component DMAController)
**
**     Description :
**         Transfer complete ISR
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(DMA1_INT_DMA0_DMA16_TransferComplete_ISR)
{
  /* {Default RTOS Adapter} ISR parameter is passed through the global variable */
  DMA1_TDeviceDataPtr DevDataPtr = INT_DMA0_DMA16__DEFAULT_RTOS_ISRPARAM;
  HandleInterrupt(&(DevDataPtr->ChnDevData[0]));
}

/*
** ===================================================================
**     Method      :  DMA1_TransferComplete_ISR (component DMAController)
**
**     Description :
**         Transfer complete ISR
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(DMA1_INT_DMA_Error_TransferError_ISR)
{
  /* {Default RTOS Adapter} ISR parameter is passed through the global variable */
  DMA1_TDeviceDataPtr DevDataPtr = INT_DMA_Error__DEFAULT_RTOS_ISRPARAM;
  HandleInterrupt(&(DevDataPtr->ChnDevData[0]));
}


/* END DMA1. */

/*!
** @}
*/
/*
** ###################################################################
**
**     This file was created by Processor Expert 10.3 [05.09]
**     for the Freescale Kinetis series of microcontrollers.
**
** ###################################################################
*/
