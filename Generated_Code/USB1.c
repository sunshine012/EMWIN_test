/* ###################################################################
**     This component module is generated by Processor Expert. Do not modify it.
**     Filename    : USB1.c
**     Project     : PE_Test
**     Processor   : MK70FN1M0VMJ15
**     Component   : USB_LDD
**     Version     : Component 01.307, Driver 01.09, CPU db: 3.00.000
**     Compiler    : GNU C Compiler
**     Date/Time   : 2019-09-24, 09:27, # CodeGen: 178
**     Abstract    :
**         This component implements an low level USB API.
**     Settings    :
**          Component name                                 : USB1
**          USB module (SIE)                               : USB0
**          Input clock frequency [MHz]                    : 48 MHz
**          Interrupt service/event                        : Enabled
**            Interrupt                                    : INT_USB0
**            Interrupt priority                           : medium priority
**          Mode                                           : HOST
**            Transceiver type                             : Internal
**              Transceiver module                         : USB0_FS
**              Transceiver weak pull-downs                : Enabled
**              USB revision                               : USB 2.0
**              Host data rates                            : 
**                Low speed                                : yes
**                Full speed                               : yes
**                High speed                               : no
**              Pin/signal setting                         : 
**                Clock pin                                : Disabled
**                USB data pins                            : 
**                  Data plus                              : 
**                    Pin                                  : USB0_DP
**                    Pin signal                           : 
**                  Data minus                             : 
**                    Pin                                  : USB0_DM
**                    Pin signal                           : 
**                VBUS pins                                : 
**                  VBUS enable                            : Disabled
**                  VBUS overcurrent                       : Disabled
**                Pullup/Pulldown pins                     : 
**                  DP pulldown                            : Enabled
**                    Pin                                  : USB0_Internal_DP_PD
**                    Pin signal                           : 
**                    Polarity                             : Activ high
**                  DM pulldown                            : Enabled
**                    Pin                                  : USB0_Internal_DM_PD
**                    Pin signal                           : 
**                    Polarity                             : Activ high
**            Host mode setting                            : 
**              Max. pipes                                 : 3
**              Max. transfers                             : 4
**              Asynchronous transfers                     : yes
**                Control transfers                        : yes
**                Bulk transfers                           : yes
**              Periodic transfers                         : no
**            Initialization                               : 
**              Enabled in init. code                      : no
**              Auto initialization                        : no
**              Event mask                                 : 
**                OnHostDeviceDeattach                     : Enabled
**                OnHostResetRecovery                      : Enabled
**                OnHostResumeRecovery                     : Enabled
**                OnHostError                              : Disabled
**                OnHost1msTimer                           : Disabled
**                OnSignalChange                           : Enabled
**          CPU clock/configuration selection              : 
**            Clock configuration 0                        : This component enabled
**            Clock configuration 1                        : This component disabled
**            Clock configuration 2                        : This component disabled
**            Clock configuration 3                        : This component disabled
**            Clock configuration 4                        : This component disabled
**            Clock configuration 5                        : This component disabled
**            Clock configuration 6                        : This component disabled
**            Clock configuration 7                        : This component disabled
**     Contents    :
**         Init               - LDD_TDeviceData * USB1_Init(LDD_TUserData *UserDataPtr);
**         Enable             - LDD_TError USB1_Enable(LDD_TDeviceData *DeviceDataPtr);
**         Disable            - LDD_TError USB1_Disable(LDD_TDeviceData *DeviceDataPtr);
**         HostGetPortState   - LDD_USB_Host_TState USB1_HostGetPortState(LDD_TDeviceData *DeviceDataPtr);
**         HostSetPortState   - LDD_TError USB1_HostSetPortState(LDD_TDeviceData *DeviceDataPtr,...
**         HostOpenPipe       - LDD_TError USB1_HostOpenPipe(LDD_TDeviceData *DeviceDataPtr,...
**         HostClosePipe      - LDD_TError USB1_HostClosePipe(LDD_TDeviceData *DeviceDataPtr,...
**         HostSendSetup      - LDD_TError USB1_HostSendSetup(LDD_TDeviceData *DeviceDataPtr,...
**         HostSendData       - LDD_TError USB1_HostSendData(LDD_TDeviceData *DeviceDataPtr,...
**         HostRecvData       - LDD_TError USB1_HostRecvData(LDD_TDeviceData *DeviceDataPtr,...
**         HostCancelTransfer - LDD_TError USB1_HostCancelTransfer(LDD_TDeviceData *DeviceDataPtr,...
**
**     Copyright : 1997 - 2014 Freescale Semiconductor, Inc. 
**     All Rights Reserved.
**     
**     Redistribution and use in source and binary forms, with or without modification,
**     are permitted provided that the following conditions are met:
**     
**     o Redistributions of source code must retain the above copyright notice, this list
**       of conditions and the following disclaimer.
**     
**     o Redistributions in binary form must reproduce the above copyright notice, this
**       list of conditions and the following disclaimer in the documentation and/or
**       other materials provided with the distribution.
**     
**     o Neither the name of Freescale Semiconductor, Inc. nor the names of its
**       contributors may be used to endorse or promote products derived from this
**       software without specific prior written permission.
**     
**     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
**     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
**     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
**     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
**     ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
**     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
**     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
**     ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
**     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
**     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
**     
**     http: www.freescale.com
**     mail: support@freescale.com
** ###################################################################*/
/*!
** @file USB1.c
** @version 01.09
** @brief
**         This component implements an low level USB API.
*/         
/*!
**  @addtogroup USB1_module USB1 module documentation
**  @{
*/         

/* MODULE USB1. */

#include "Events.h"
#include "USB1.h"
/* {Default RTOS Adapter} No RTOS includes */
#include "USB_PDD.h"

#define USB1_AVAILABLE_IN_SIGNALS_MASK ((LDD_TPinMask)(0x00U))

#define USB1_IN_SIGNALS_INIT_VALUE ((LDD_TPinMask)(0x00U))

/* BD Endpoint control access macros */
#define USB1_BD_OWM                               0x00000080U
#define USB1_BD_DATA0                             0x00000000U
#define USB1_BD_DATA1                             0x00000040U
#define USB1_BD_KEEP                              0x00000020U
#define USB1_BD_NINC                              0x00000010U
#define USB1_BD_DTS                               0x00000008U
#define USB1_BD_STALL                             0x00000004U

#define USB1_BD_PID_BUS_TIMEOUT                   0x00000000U
#define USB1_BD_PID_DATA0                         0x0000000CU
#define USB1_BD_PID_DATA1                         0x0000002CU
#define USB1_BD_PID_ACK                           0x00000008U
#define USB1_BD_PID_STALL                         0x00000038U
#define USB1_BD_PID_NACK                          0x00000028U
#define USB1_BD_PID_DATA_ERROR                    0x0000003CU
#define USB1_BD_PID_MASK                          0x0000003CU

#define USB1_BD_LE_OWM                            0x80000000U
#define USB1_BD_LE_DATA1                          0x40000000U
#define USB1_BD_LE_STALL                          0x04000000U

#define USB1_HOST_DEBOUNCE_INTERVAL_MS            0x64
#define USB1_HOST_RESET_INTERVAL_MS               0x32
#define USB1_HOST_RESET_RECOVERY_INTERVAL_MS      0x0A
#define USB1_HOST_RESUME_INTERVAL_MS              0x14
#define USB1_HOST_RESUME_RECOVERY_INTERVAL_MS     0x0A

#define MAX_PIPES                                 0x03u
#define MAX_TRANSFERS                             0x04u

#define LDD_USB_DIR_UNKNOWN                       0xFFu
#define USB1_A_WAIT_VRISE_TIME_OUT_MS             0x64
#define USB1_A_WAIT_BCON_SHORT_DEBOUCE_MS         0x01
#define USB1_A_WAIT_BCON_LONG_DEBOUCE_MS          0x64
#define USB1_A_WAIT_BCON_TIME_OUT_MS              0x044C
#define USB1_A_IDLE_BDIS_TIME_OUT_MS              0xC8
#define USB1_B_ASE0_TIME_OUT_MS                   0x9B
#define USB1_B_SE0_SRP_TIME_OUT_MS                0x03
#define USB1_B_DATA_PLS_TIME_OUT_MS               0x07

/* OTG input variables */
#define USB1_OTG_TIMEOUT                          0x80000000u
#define USB1_OTG_1MS_TIMEOUT                      0x40000000u
#define USB1_OTG_A_BUS_RESUME                     0x20000000u
#define USB1_OTG_A_BUS_SUSPEND                    0x10000000u
#define USB1_OTG_A_CONN                           0x08000000u
#define USB1_OTG_A_SESSION_VALID                  0x08u
#define USB1_OTG_A_SRP_DET                        0x04000000u
#define USB1_OTG_A_VBUS_VALID                     0x01u
#define USB1_OTG_B_BUS_RESUME                     0x02000000u
#define USB1_OTG_B_BUS_SUSPEND                    0x01000000u
#define USB1_OTG_B_CONN                           0x00800000u
#define USB1_OTG_B_SE0_SRP                        0x00400000u
#define USB1_OTG_B_SESSION_VALID                  0x08u
#define USB1_OTG_B_SESSION_END                    0x04u
#define USB1_OTG_ID                               0x80u

#define USB1_OTG_VBUS_VALID                       0x01u
#define USB1_OTG_SESSION_VALID                    0x08u

/* Informative variables */
#define USB1_OTG_A_BUS_DROP                       0x00200000u
#define USB1_OTG_A_BUS_REQ                        0x00100000u
#define USB1_OTG_A_CLR_ERR                        0x00080000u
#define USB1_OTG_A_SUSPEND_REQ                    0x00040000u
#define USB1_OTG_B_BUS_REQ                        0x00020000u

/* Internal variables */
#define USB1_TIMEOUT                              0x02u
#define USB1_1MS_TIMEOUT                          0x40u
#define USB1_OTG_A_SET_B_HNP_EN                   0x00010000u
#define USB1_OTG_B_SRP_DONE                       0x8000u
#define USB1_OTG_B_HNP_EN                         0x4000u
#define USB1_OTG_NOT_SE0                          0x2000u

#define USB1_DEVICE_VBUS_DETECT                   0x04u
#define USB1_HOST_VBUS_OVERCURRENT                0x04u

#define USB1_EnableTimer() USB_PDD_Enable1msInterrupt(USB0_BASE_PTR)

/* Buffer descriptor table item structure */
typedef struct USB1_TBD_Struct {
  uint32_t                        CtrlReg;
  uint32_t                        BufferPtr;
} USB1_TBD;

typedef enum {
  USB1_PIPE_CLOSED            = 0x00u,
  USB1_PIPE_IDLE              = 0x01u,
  USB1_PIPE_BUSY              = 0x02u,
  USB1_PIPE_CANCEL_PENDING    = 0x03u
} USB1_TPipeState;

typedef enum {
  USB1_TRANSFER_NONE               = 0x00u,
  USB1_TRANSFER_DONE               = 0x01u,
  USB1_TRANSFER_ERROR_CANCELLED    = 0x02u,
  USB1_TRANSFER_ERROR_STALLED      = 0x03u,
  USB1_TRANSFER_ERROR_BUS_TIMEOUT  = 0x04u,
  USB1_TRANSFER_ERROR_DATA         = 0x05u,
  USB1_TRANSFER_ERROR_PID          = 0x06u,
  USB1_TRANSFER_ERROR_EOF          = 0x07u,
  USB1_TRANSFER_ERROR_CRC16        = 0x08u,
  USB1_TRANSFER_ERROR_DFN8         = 0x09u,
  USB1_TRANSFER_ERROR_DMA          = 0x0Au,
  USB1_TRANSFER_ERROR_BTS          = 0x0Bu,
  USB1_TRANSFER_ERROR              = 0x0Fu,
  USB1_TRANSFER_QUEUED             = 0x10u,
  USB1_TRANSFER_PENDING            = 0x30u,
  USB1_TRANSFER_DATA_QUEUED        = 0x50u,
  USB1_TRANSFER_DATA_PENDING       = 0x70u,
  USB1_TRANSFER_SETUP_QUEUED       = 0x90u,
  USB1_TRANSFER_SETUP_PENDING      = 0xB0u,
  USB1_TRANSFER_HSK_QUEUED         = 0xD0u,
  USB1_TRANSFER_HSK_PENDING        = 0xF0u
} USB1_TTrState;

/* Transfer descriptor (TD) structure */
typedef struct USB1_TTrDescr_Struct {
  LDD_USB_Host_TTD                 Head;         /* Public part of the TD */
  USB1_TTrState                    TrState;      /* Transfer state */
  uint8_t                         *tmpBufferPtr; /* Buffer address */
  struct USB1_TTrDescr_Struct     *NextTrPtr;    /* Next TD address */
  uint8_t                          ErrorCounter; /* Transaction error counter */
} USB1_TTrDescr;

/* Pipe descriptor (PD) structure */
typedef struct USB1_TPipeDescr_Struct {
  LDD_USB_Host_TPipeDescr          Head;         /* Public part of the PD */
  struct USB1_TPipeDescr_Struct   *NextPipePtr;  /* Next pipe address */
  USB1_TPipeState                  PipeState;    /* Pipe state */
  uint8_t                          NextData01;   /* DATA pid for next packet  */
  bool                             ZLT;
  USB1_TTrDescr                   *ActiveTrPtr;  /* Address of the first TD */
  USB1_TTrDescr                   *LastTrPtr;    /* Address of the first TD */
  uint8_t                          EpCtrlRegVal; /* Predefined value for EP control register */
} USB1_TPipeDescr;


/* Device data structure */
typedef struct USB1_TDeviceData_Struct {
  USB1_TBD                         BDT[0x04];    /* Buffer descriptor array */
  LDD_USB_Host_TState              HostState;    /* Internal host engine state */
  USB1_TPipeDescr                  PDT[MAX_PIPES]; /* Pipe descriptor array */
  USB1_TTrDescr                    TDT[MAX_TRANSFERS]; /* Transfer descriptor array */
  USB1_TPipeDescr                 *AsyncPipeListHeadPtr; /* Asynchronous pipes list head address */
  USB1_TPipeDescr                 *AsyncPipeListTailPtr; /* Asynchronous pipes list head address */
  USB1_TTrDescr                   *FreeTDListPtr; /* Free transfer descriptor list address */
  USB1_TPipeDescr                 *ActivePipePtr; /* Current device state */
  USB1_TBD                        *RxBDPtr;      /* Empty Rx buffer descriptor address */
  USB1_TBD                        *TxBDPtr;      /* Empty Tx buffer descriptor address */
  LDD_USB_TBusSpeed                BusSpeed;     /* Bus speed */
  LDD_TUserData                   *UserHostDataPtr; /* Host mode user device data structure */
  uint8_t                          SofThresholdValue; /* Sof threshold detected */
  bool                             ISR;          /* TRUE if ISR is in progress */
  bool                             EnUser;       /* Enable/Disable device state variable */
  uint32_t                         InSignalsState; /* Input signals state variable */
  int32_t                          msCounter;    /* 1ms counter */
} USB1_TDeviceData, *USB1_TDeviceDataPtr;

/* {Default RTOS Adapter} Static object used for simulation of dynamic driver memory allocation */
static USB1_TDeviceData DevDataPtr__DEFAULT_RTOS_ALLOC __attribute__ ((aligned (512)));
/* {Default RTOS Adapter} Global variable used for passing a parameter into ISR */
static USB1_TDeviceDataPtr INT_USB0__DEFAULT_RTOS_ISRPARAM;
static void USB1_StartTimer(USB1_TDeviceData *DevDataPtr, int32_t Timeout);
static void USB1_HostIsr(USB1_TDeviceData *DevDataPtr, uint32_t InSignalsState);

/*
** ===================================================================
**     Method      :  USB1_UsbLock (component USB_LDD)
**
**     Description :
**         USB lock
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB1_UsbLock(USB1_TDeviceData *DevDataPtr)
{
  if (!DevDataPtr->ISR) {
    /* {Default RTOS Adapter} Critical section begin, general PE function is used */
    EnterCritical();
  }
}

/*
** ===================================================================
**     Method      :  USB1_UsbUnlock (component USB_LDD)
**
**     Description :
**         USB unlock
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB1_UsbUnlock(USB1_TDeviceData *DevDataPtr)
{
  if (!DevDataPtr->ISR) {
    /* {Default RTOS Adapter} Critical section end, general PE function is used */
    ExitCritical();
  }
}

/*
** ===================================================================
**     Method      :  USB1_StartTimer (component USB_LDD)
**
**     Description :
**         Starts timer.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB1_StartTimer(USB1_TDeviceData *DevDataPtr, int32_t Timeout)
{
  DevDataPtr->msCounter = Timeout;                         /* Remember timeout */
  USB1_EnableTimer();                                      /* Enable timer */
}

/*
** ===================================================================
**     Method      :  USB1_HostStartTransaction (component USB_LDD)
**
**     Description :
**         Starts transaction described by the TD on the head of the 
**         active pipe (DevDataPtr->ActivePipePtr->ActiveTrPtr)
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB1_HostStartTransaction(USB1_TDeviceData *DevDataPtr) {
  USB1_TBD                         *BDPtr;
  USB1_TTrDescr                    *TrPtr;
  uint8_t                          *BufferPtr;
  uint32_t                          BDCtrlRegVal;
  uint8_t                           Token;

  TrPtr = DevDataPtr->ActivePipePtr->ActiveTrPtr;                    /* Get transfer descriptor */
  if (TrPtr->TrState == USB1_TRANSFER_SETUP_QUEUED) {
   /* Setup packet */
    BDPtr               = DevDataPtr->TxBDPtr;                       /* Remember BD address */
    DevDataPtr->TxBDPtr = (USB1_TBD *)((uint32_t)(DevDataPtr->TxBDPtr) ^ 0x08U); /* Update next BD address pointer */
    BufferPtr           = (uint8_t*)(void*)TrPtr->Head.SDPPrt;       /* Remember setup data buffer address */
    BDCtrlRegVal        = 0x00080080U;                               /* Prepare BD ctrl. reg. value, Size =8, OWN = 1 DATA0 */
    Token               = (uint8_t)(LDD_USB_PID_SETUP << 0x04U);     /* Prepare Token reg. value (SETUP)*/
  } else {
    /* Data packet */
    BufferPtr           = TrPtr->tmpBufferPtr;                       /* Remember data buffer address */
    BDCtrlRegVal        = TrPtr->Head.BufferSize;                    /* Remember remaining data size */
    if (BDCtrlRegVal > DevDataPtr->ActivePipePtr->Head.MaxPacketSize) { /* Remaining data size > then Max packet size? */
      BDCtrlRegVal = DevDataPtr->ActivePipePtr->Head.MaxPacketSize;  /* Yes, send 'MaxPacketSize' length packet */
    }
    BDCtrlRegVal = (BDCtrlRegVal << 0x10) | USB1_BD_OWM | DevDataPtr->ActivePipePtr->NextData01; /* Prepare BD ctrl. reg. value */
    if (DevDataPtr->ActivePipePtr->Head.EpDir == LDD_USB_DIR_OUT) {
      Token               = (uint8_t)(LDD_USB_PID_OUT << 0x04U);     /* Prepare Token reg. value (OUT)*/
      BDPtr               = DevDataPtr->TxBDPtr;                     /* Remember BD address */
      DevDataPtr->TxBDPtr = (USB1_TBD *)((uint32_t)(DevDataPtr->TxBDPtr) ^ 0x08U); /* Update next BD address pointer */
    } else {
      Token               = (uint8_t)(LDD_USB_PID_IN << 0x04U);      /* Prepare Token reg. value (IN)*/
      BDPtr               = DevDataPtr->RxBDPtr;                     /* Remember BD address */
      DevDataPtr->RxBDPtr = (USB1_TBD *)((uint32_t)(DevDataPtr->RxBDPtr) ^ 0x08U); /* Update next BD address pointer */
    }
  }
  TrPtr->TrState =  (USB1_TTrState)((uint32_t)TrPtr->TrState | (uint32_t)USB1_TRANSFER_PENDING); /* Update transfer state */
  BDPtr->BufferPtr = (uint32_t)BufferPtr;                            /* Set buffer address */
  BDPtr->CtrlReg = BDCtrlRegVal;                                     /* Set packet properties */
  Token = (uint8_t)(Token | DevDataPtr->ActivePipePtr->Head.EpNumber); /* Add EP address to the token reg. value */
  USB_PDD_WriteEp0CtrlReg(USB0_BASE_PTR, DevDataPtr->ActivePipePtr->EpCtrlRegVal); /* Set EP handshake and retry policy */
  USB_PDD_WriteAddressReg(USB0_BASE_PTR, DevDataPtr->ActivePipePtr->Head.DevAddress); /* Start transaction */
  USB_PDD_ClearErrorsInterruptFlags(USB0_BASE_PTR, USB_PDD_ALL_INT_FLAGS); /* Clear error flags */
  USB_PDD_WriteTokenReg(USB0_BASE_PTR, Token);
}

/*
** ===================================================================
**     Method      :  USB1_HostQueueTransfer (component USB_LDD)
**
**     Description :
**         Queues transfer descriptor
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static  LDD_TError HostQueueTransfer(
  LDD_TDeviceData               *DeviceDataPtr,
  LDD_USB_Host_TPipeHandle      *PipeHndPtr,
  LDD_USB_Host_TTD              *TrDscrPtr,
  LDD_USB_Host_TTransferHandle **TrHndPtr,
  uint32_t                       TrDir
)
{
  USB1_TDeviceData                 *DevDataPtr = (USB1_TDeviceData*)DeviceDataPtr;
  USB1_TPipeDescr                  *PipePtr = (USB1_TPipeDescr*)PipeHndPtr;
  USB1_TTrDescr                    *TrPtr;
  LDD_TError                        Res = ERR_OK;

  /* Input parameter test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  if (PipePtr == NULL) {
    return ERR_PARAM_ADDRESS;
  }
  /* Input parameter test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  if (TrDscrPtr == NULL) {
    return ERR_PARAM_ADDRESS;
  }
  /* Input parameter test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  if ((TrDir == LDD_USB_DIR_UNKNOWN) && (TrDscrPtr->SDPPrt == NULL)) {
    return ERR_PARAM_DATA;
  }
  USB1_UsbLock(DevDataPtr);
  if (PipePtr->PipeState == USB1_PIPE_CLOSED) {                 /* Pipe closed? */
    USB1_UsbUnlock(DevDataPtr);
    return ERR_FAILED;                                          /* Return with error */
  }
  if (DevDataPtr->HostState != LDD_USB_HOST_PORT_ENABLED) {     /* Port ready to transfer data? */
    Res = (LDD_TError)DevDataPtr->HostState;                    /* Return with error */
  } else {
    TrPtr = DevDataPtr->FreeTDListPtr;                          /* Try to get a free TD */
    if (TrPtr != NULL) {                                        /* Found free TD? */
      DevDataPtr->FreeTDListPtr        = TrPtr->NextTrPtr;      /* Yes, dequeue it from free TD queue */
      *(LDD_USB_Host_TTD*)(void*)TrPtr = *TrDscrPtr;            /* Copy user transfer settings */
      TrPtr->tmpBufferPtr              = (uint8_t *)TrPtr->Head.BufferPtr; /* Remember start of data buffer */
      TrPtr->ErrorCounter              = 0x03U;                 /* Max. 3 errors are allowed for transaction */
      TrPtr->NextTrPtr                 = NULL;                  /* This is the last TD in the pipe's TD queue */
      if (PipePtr->ActiveTrPtr == NULL) {                       /* Transfer pending on this pipe? */
        PipePtr->ActiveTrPtr = TrPtr;                           /* No, put this TD on the pipe's TD queue head */
      } else {
        PipePtr->LastTrPtr->NextTrPtr = TrPtr;                  /* Tr. pending, put this TD on the pipe's TD queue tail */
      }
      PipePtr->LastTrPtr = TrPtr;                               /* Update pipe's TD queue tail pointer */
      if ((PipePtr->Head.TransferType == LDD_USB_CONTROL) && (TrDscrPtr->SDPPrt != NULL)) { /* Control pipe and Setup transaction? */
        TrPtr->TrState      = USB1_TRANSFER_SETUP_QUEUED;       /* Set transfer state */
        PipePtr->Head.EpDir = (uint8_t)(TrDscrPtr->SDPPrt->bmRequestType & (uint8_t)LDD_USB_DIR_MASK); /* Set transfer direction according to SDP */
      } else {                                                  /* Non control pipe or no Setup transaction */
        TrPtr->TrState      = USB1_TRANSFER_DATA_QUEUED;        /* Set transfer state */
        PipePtr->Head.EpDir = (uint8_t)TrDir;
      }
      if (DevDataPtr->ActivePipePtr == NULL) {                  /* Any transfer pending? */
        DevDataPtr->ActivePipePtr = PipePtr;                    /* No, make this pipe active */
        USB1_HostStartTransaction(DevDataPtr);                  /* Start transfers */
        USB_PDD_EnableTokenDoneInterrupt(USB0_BASE_PTR);
      }
    } else {
      Res = ERR_QFULL;                                          /* No free transfer descriptor */
    }
    if (TrHndPtr != NULL) {                                     /* Request to return transfer handle? */
      *TrHndPtr = (LDD_USB_Host_TTransferHandle*)TrPtr;         /* Yes, put handle to the provided variable */
    }
  }
  USB1_UsbUnlock(DevDataPtr);
  return Res;
}

/*
** ===================================================================
**     Method      :  USB1_HostTransferDone (component USB_LDD)
**
**     Description :
**         Transfer done handler
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB1_HostTransferDone(USB1_TDeviceData *DevDataPtr, USB1_TPipeDescr *PipePtr)
{
  USB1_TTrDescr *TrPtr;

  /* Call user callback if required */
  TrPtr = PipePtr->ActiveTrPtr;        /* Remember current TD address */
  if (TrPtr->Head.CallbackFnPtr != NULL) {
    TrPtr->Head.CallbackFnPtr(
      DevDataPtr->UserHostDataPtr,
      TrPtr->Head.BufferPtr,
      (uint16_t)((uint32_t)TrPtr->tmpBufferPtr - (uint32_t)TrPtr->Head.BufferPtr),
      TrPtr->Head.ParamPtr,
      (LDD_USB_TTransferState)((uint32_t)(TrPtr->TrState) & (uint32_t)0x3F)
    );
  }
  /* Put TD back to the free TD list */
  PipePtr->ActiveTrPtr = TrPtr->NextTrPtr;                      /* Get next transfer descriptor for the pipe */
  TrPtr->NextTrPtr = DevDataPtr->FreeTDListPtr;                 /* Retun current TD to the free TD list */
  DevDataPtr->FreeTDListPtr = TrPtr;
}

/*
** ===================================================================
**     Method      :  USB1_HostQueueFlush (component USB_LDD)
**
**     Description :
**         Removes all pending TDs from pipe's TD queue
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB1_HostQueueFlush(USB1_TDeviceData *DevDataPtr, USB1_TPipeDescr *PipePtr,USB1_TTrState TrState)
{
  if (USB_PDD_GetTokenBusyFlag(USB0_BASE_PTR)) {                /* Any transaction in progress? */
    if (DevDataPtr->ActivePipePtr == PipePtr) {                 /* Transaction for this pipe? */
      while(USB_PDD_GetTokenBusyFlag(USB0_BASE_PTR)) {}         /* Wait for transaction end */
      while(!USB_PDD_GetTokenDoneInterruptFlag(USB0_BASE_PTR)) {} /* Wait until transaction end interrupt flag is set */
      PipePtr->PipeState = USB1_PIPE_CANCEL_PENDING;
      USB1_HostIsr(DevDataPtr, DevDataPtr->InSignalsState);
      PipePtr->PipeState = USB1_PIPE_IDLE;
    }
  }
  while (PipePtr->ActiveTrPtr) {                                /* For all TDs in pipe's queue do: */
    PipePtr->ActiveTrPtr->TrState = TrState;                    /* Set requested transfer state */
    USB1_HostTransferDone(DevDataPtr, PipePtr);                 /* Call transfer complete handler */
  }
}

/*
** ===================================================================
**     Method      :  USB1_CloseAllPipes (component USB_LDD)
**
**     Description :
**         Closes all pipes and discards all pending transfers
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB1_HostCloseAllPipesAndDiscardAlltransfers(USB1_TDeviceData *DevDataPtr) {
  USB1_TTrDescr                   *TrPtr;
  uint32_t                         x;

  USB1_UsbLock(DevDataPtr);
  DevDataPtr->FreeTDListPtr = &DevDataPtr->TDT[0x00]; /* Set FreeTDListPtr to the begin of TD array */
  TrPtr = DevDataPtr->FreeTDListPtr;   /* Go through the TD array and cancel all pending transfers */
  for (x = 0x00U; x < MAX_TRANSFERS; x++) {
    if (TrPtr->TrState >= USB1_TRANSFER_QUEUED) { /* Pending transfer? */
      TrPtr->TrState = USB1_TRANSFER_ERROR_CANCELLED; /* Call callback */
      if (TrPtr->Head.CallbackFnPtr != NULL) {
        TrPtr->Head.CallbackFnPtr(DevDataPtr->UserHostDataPtr, TrPtr->Head.BufferPtr, TrPtr->Head.BufferSize, TrPtr->Head.ParamPtr, LDD_USB_TRANSFER_ERROR_CANCELLED);
      }
    }
    TrPtr->NextTrPtr = TrPtr + 0x01;   /* Add next TD to the FreeTDListPtr list */
    TrPtr++;                           /* Take next TD item */
  }
  TrPtr->NextTrPtr = NULL;             /* Last TD in the array is the last item in the FreeTDList */
  for (x = 0x00U; x < MAX_PIPES; x++) { /* Go through the Pipe array and set pipe state to "CLOSED" */
    DevDataPtr->PDT[x].PipeState = USB1_PIPE_CLOSED;
  }
  for (x = 0x00U; x < 0x04U; x++) {    /* Go through the Pipe array and set pipe state to "CLOSED" */
    DevDataPtr->BDT[x].CtrlReg = 0x00U;
  }
  USB_PDD_ResetBdtPingPong(USB0_BASE_PTR);
  USB_PDD_EnableControlEP(USB0_BASE_PTR, 0x00, PDD_DISABLE);
  DevDataPtr->AsyncPipeListHeadPtr = NULL;
  DevDataPtr->AsyncPipeListTailPtr = NULL;
  DevDataPtr->SofThresholdValue = 0x00U;
  DevDataPtr->ActivePipePtr = NULL;
  DevDataPtr->RxBDPtr = &DevDataPtr->BDT[0x00];
  DevDataPtr->TxBDPtr = &DevDataPtr->BDT[0x02];
  USB1_UsbUnlock(DevDataPtr);
}

/*
** ===================================================================
**     Method      :  USB1_HostDisabledPort (component USB_LDD)
**
**     Description :
**         Sets the port to the DISABLED state and closes all pipes and 
**         discards all pending transfers. This state can be changed only 
**         by performing the bus reset(transfer to the ENABLED state), by 
**         disconnecting the device (transfer to the DISCONNECT state) or 
**         by the powering-off the bus (transfer to the POWERED_OFF 
**         state).
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB1_HostDisabledPort(USB1_TDeviceData *DevDataPtr) {
  /* Called from ISR if "disconnect" event is detected */
  USB_PDD_EnableSof(USB0_BASE_PTR, PDD_DISABLE);                /* Disable SOF */
  USB_PDD_EnableDirectLowSpeedDevice(USB0_BASE_PTR, PDD_DISABLE); /* This is necessary to correctly detect device speed */
  USB_PDD_EnableLowSpeed(USB0_BASE_PTR, PDD_DISABLE);           /* This is necessary to correctly detect device speed */
  USB_PDD_SetUsbInterruptMask(USB0_BASE_PTR,USB_PDD_ATTACH_INT); /* Enable only "attach" interrupt */
  DevDataPtr->HostState = LDD_USB_HOST_PORT_DISABLED;
  USB1_HostCloseAllPipesAndDiscardAlltransfers(DevDataPtr);
}

/*
** ===================================================================
**     Method      :  USB1_HostResetPort (component USB_LDD)
**
**     Description :
**         Sets the port to the RESET state, starts the reset signaling, 
**         and closes all pipes and discards all pending transfers. As 
**         soon as the reset interval is elapsed the reset signaling will 
**         be stopped, the port state will be change to the 
**         RESET_RECOVERING, and the reset recovery interval will begin. 
**         After the reset recovery interval is elapsed, the port state 
**         will be changed to the ENABLED state. In the ENABLED state the 
**         port can used to transfer data.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB1_HostResetPort(USB1_TDeviceData *DevDataPtr) {
  do {
    USB_PDD_ClearTokenBusyFlag(USB0_BASE_PTR);
  } while (USB_PDD_GetTokenBusyFlag(USB0_BASE_PTR));
  DevDataPtr->HostState = LDD_USB_HOST_PORT_RESETING;           /* Set new state */
  USB1_HostCloseAllPipesAndDiscardAlltransfers(DevDataPtr);     /* Cancel all transfers */
  USB_PDD_EnableSof(USB0_BASE_PTR, PDD_DISABLE);                /* Disable SOF */
  USB_PDD_SetUsbInterruptMask(USB0_BASE_PTR, 0x00);             /* Disable all interrupt */
  USB_PDD_StartResetSignaling(USB0_BASE_PTR, PDD_ENABLE);       /* Start reset signaling */
  USB1_StartTimer(DevDataPtr, USB1_HOST_RESET_INTERVAL_MS + 1);  /* Start reset signaling */
}

/*
** ===================================================================
**     Method      :  USB1_HostSuspendPort (component USB_LDD)
**
**     Description :
**         Suspends port. No transaction should be pending before this 
**         method is called.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB1_HostSuspendPort(USB1_TDeviceData *DevDataPtr) {
  DevDataPtr->HostState = LDD_USB_HOST_PORT_SUSPENDED;          /* Set new state */
  do {                                                          /* Wait till the token(SOF) is done */
  } while (USB_PDD_GetTokenBusyFlag(USB0_BASE_PTR));
  USB_PDD_EnableSof(USB0_BASE_PTR, PDD_DISABLE);                /* Disable SOF */
  USB_PDD_EnableDirectLowSpeedDevice(USB0_BASE_PTR, PDD_DISABLE); /* This is necessary not to detect false resume */
  USB_PDD_EnableLowSpeed(USB0_BASE_PTR, PDD_DISABLE);           /* This is necessary not to detect false resume */
  USB_PDD_ClearUsbInterruptFlags(USB0_BASE_PTR,0xFF);           /* Clear all interrupt flags */
  USB_PDD_SetUsbInterruptMask(USB0_BASE_PTR, USB_PDD_RESUME_INT); /* Enable "resume" interrupt */
  USB_PDD_SuspendTransceiver(USB0_BASE_PTR, PDD_ENABLE);        /* Suspend transceiver */
  USB1_StartTimer(DevDataPtr, 4);                                /* Enable deattach(USB 2.0 chapter 11.5.1.9) interrupt 4 ms later */
}

/*
** ===================================================================
**     Method      :  USB1_HostResumePort (component USB_LDD)
**
**     Description :
**         Resumes port.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB1_HostResumePort(USB1_TDeviceData *DevDataPtr) {
  USB_PDD_SuspendTransceiver(USB0_BASE_PTR, PDD_DISABLE);       /* Wake up transceiver */
  USB_PDD_SetUsbInterruptMask(USB0_BASE_PTR,USB_PDD_USB_RST_INT); /* Enable only "deattach" interrupt */
  if (DevDataPtr->BusSpeed == LDD_USB_LOW_SPEED) {
    USB_PDD_EnableDirectLowSpeedDevice(USB0_BASE_PTR, PDD_ENABLE); /* This is necessary not to detect false resume */
    USB_PDD_EnableLowSpeed(USB0_BASE_PTR, PDD_ENABLE);          /* This is necessary not to detect false resume */
  }
  USB_PDD_StartResumeSignaling(USB0_BASE_PTR, PDD_ENABLE);
  DevDataPtr->HostState = LDD_USB_HOST_PORT_RESUMING;           /* Remember new state */
  USB1_StartTimer(DevDataPtr, USB1_HOST_RESUME_INTERVAL_MS + 1); /* Start resume signaling */
}

/*
** ===================================================================
**     Method      :  USB1_Init (component USB_LDD)
*/
/*!
**     @brief
**         Initializes USB device. Allocates memory for the device data
**         structure, interrupts, pins, etc. This method doesn't enable
**         device pull-up. Use Enable() method to enable device pull-up.
**     @param
**         UserDataPtr     - Pointer to the user or
**                           RTOS specific data. This pointer will be
**                           passed as an event or callback parameter.
**     @return
**                         - Pointer to the dynamically allocated private
**                           structure or NULL if there was an error.
*/
/* ===================================================================*/
LDD_TDeviceData * USB1_Init(LDD_TUserData *UserDataPtr)
{
  USB1_TDeviceData                *DevDataPtr;

  /* Allocate HAL device structure */
  /* {Default RTOS Adapter} Driver memory allocation: Dynamic allocation is simulated by a pointer to the static object */
  DevDataPtr = &DevDataPtr__DEFAULT_RTOS_ALLOC;
  /* {Default RTOS Adapter} Driver memory allocation: Fill the allocated memory by zero value */
  PE_FillMemory(DevDataPtr, 0U, sizeof(USB1_TDeviceData));
  DevDataPtr->UserHostDataPtr = UserDataPtr; /* Store the RTOS device structure */
  /* Interrupt vector(s) allocation */
  /* {Default RTOS Adapter} Set interrupt vector: IVT is static, ISR parameter is passed by the global variable */
  INT_USB0__DEFAULT_RTOS_ISRPARAM =  DevDataPtr;
  /* Interrupt vector(s) priority setting */
  /* NVICIP73: PRI73=0x80 */
  NVICIP73 = NVIC_IP_PRI73(0x80);
  /* NVICISER2: SETENA|=0x0200 */
  NVICISER2 |= NVIC_ISER_SETENA(0x0200);
  /* Clock setting */
  /* Input clock source:      PLL1 clock */
  /* Input clock frequency:   120 MHz */
  /* Input clock multiplier:  2 */
  /* Input clock divider:     5 */
  /* Module clock frequency:  48 MHz */
  /* SIM_SOPT2: USBFSRC=2,USBF_CLKSEL=1 */
  SIM_SOPT2 = (uint32_t)((SIM_SOPT2 & (uint32_t)~(uint32_t)(
               SIM_SOPT2_USBFSRC(0x01)
              )) | (uint32_t)(
               SIM_SOPT2_USBFSRC(0x02) |
               SIM_SOPT2_USBF_CLKSEL_MASK
              ));                      /* Clock source=Divided Pll1 clock */
  /* SIM_CLKDIV2: USBFSDIV=4,USBFSFRAC=1 */
  SIM_CLKDIV2 = (uint32_t)((SIM_CLKDIV2 & (uint32_t)~(uint32_t)(
                 SIM_CLKDIV2_USBFSDIV(0x03)
                )) | (uint32_t)(
                 SIM_CLKDIV2_USBFSDIV(0x04) |
                 SIM_CLKDIV2_USBFSFRAC_MASK
                ));                    /* Div=5 - Mult=2  */
  /* Enable module clock */
  /* SIM_SCGC4: USBFS=1 */
  SIM_SCGC4 |= SIM_SCGC4_USBFS_MASK;
  /* Reset module */
  /* USB0_USBTRC0: USBRESET=1 */
  USB0_USBTRC0 = USB_USBTRC0_USBRESET_MASK; /* Reset module */
  while (USB_PDD_GetModuleResetPendingFlag(USB0_BASE_PTR)) {
    ; /* Wait for reset done */
  }
  /* Enable USB voltage regulator */
  /* SIM_SOPT1: ??=1 */
  SIM_SOPT1 |= 0x80U;                  /* Enable USB voltage regulator */
  /* USB0_USBCTRL: SUSP=1,PDE=0 */
  USB0_USBCTRL = USB_USBCTRL_SUSP_MASK; /* Enable weak pull-downs and suspend transceiver */
  /* USB0_OTGCTL: DPHIGH=0,??=0,DPLOW=1,DMLOW=1,??=0,OTGEN=1,??=0,??=0 */
  USB0_OTGCTL = USB_OTGCTL_DPLOW_MASK |
                USB_OTGCTL_DMLOW_MASK |
                USB_OTGCTL_OTGEN_MASK;
  /* Set BDT address */
  USB0_BDTPAGE1 = (uint8_t)((((uint32_t)DevDataPtr) >> 8) & 0xFEU);
  USB0_BDTPAGE2 = (uint8_t)((((uint32_t)DevDataPtr) >> 16) & 0xFFU);
  USB0_BDTPAGE3 = (uint8_t)((((uint32_t)DevDataPtr) >> 24) & 0xFFU);
  /* Initialize device data structure */
  DevDataPtr->HostState = LDD_USB_HOST_DISABLED;
  DevDataPtr->msCounter = -1;                               /* No timing request */
  DevDataPtr->EnUser = FALSE;
  /* Registration of the device structure */
  PE_LDD_RegisterDeviceStructure(PE_LDD_COMPONENT_USB1_ID,DevDataPtr);
  return (LDD_TDeviceData*)(DevDataPtr);                    /* Return pointer to the data data structure */
}

/*
** ===================================================================
**     Method      :  USB1_Enable (component USB_LDD)
*/
/*!
**     @brief
**         Enables the USB device (PHY, SIE). Enables device's DP(DM)
**         pull-up.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @return
**                         - 
*/
/* ===================================================================*/
LDD_TError USB1_Enable(LDD_TDeviceData *DeviceDataPtr)
{
  USB1_TDeviceData                *DevDataPtr = (USB1_TDeviceData*)DeviceDataPtr;

  if (!DevDataPtr->EnUser) {
    DevDataPtr->EnUser = TRUE;
    USB1_UsbLock(DevDataPtr);
    USB_PDD_SetErrorInterruptMask(USB0_BASE_PTR, 0x00U);   /* Disable all "Error" interrupts */
    USB_PDD_ClearUsbInterruptFlags(USB0_BASE_PTR, USB_PDD_ALL_INT_FLAGS); /* Clear "Attach" interrupt flag */
    USB_PDD_SetUsbInterruptMask(USB0_BASE_PTR, USB_PDD_ATTACH_INT); /* Enable "Attach" interrupt */
    DevDataPtr->msCounter = -1;                            /* No timing request */
    DevDataPtr->HostState = LDD_USB_HOST_PORT_DISCONNECTED; /* Update state variable */
    USB_PDD_SuspendTransceiver(USB0_BASE_PTR, PDD_DISABLE); /* Enable transceiver */
    USB_PDD_WriteOtgControlReg(USB0_BASE_PTR, (USB_PDD_ReadOtgControlReg(USB0_BASE_PTR) | (uint8_t)0x30)); /* Enable D+- pull-downs. Enable VBUS */
    USB_PDD_Disable1msInterrupt(USB0_BASE_PTR);            /* Disable "1ms" interrupt */
    USB_PDD_EnableHost(USB0_BASE_PTR, PDD_ENABLE);         /* Enable host mode */
    USB1_UsbUnlock(DevDataPtr);
  }
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  USB1_Disable (component USB_LDD)
*/
/*!
**     @brief
**         Disabled device's DP(DM) pull-up. Disables PHY, etc.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @return
**                         - 
*/
/* ===================================================================*/
LDD_TError USB1_Disable(LDD_TDeviceData *DeviceDataPtr)
{
  USB1_TDeviceData                *DevDataPtr = (USB1_TDeviceData*)DeviceDataPtr;

  if (DevDataPtr->EnUser) {
    DevDataPtr->EnUser = FALSE;
    USB1_UsbLock(DevDataPtr);
    if (DevDataPtr->HostState > LDD_USB_HOST_PORT_DISCONNECTED) {
      DevDataPtr->HostState = LDD_USB_HOST_PORT_DISCONNECTED;
      USB1_OnHostDeviceDeattach(DevDataPtr->UserHostDataPtr);
    }
    DevDataPtr->HostState = LDD_USB_HOST_DISABLED;         /* Update state variable */
    DevDataPtr->msCounter = -1;                            /* No timing request */
    USB_PDD_DisableModule(USB0_BASE_PTR);                  /* Disable module */
    USB_PDD_SuspendTransceiver(USB0_BASE_PTR, PDD_ENABLE); /* Disable transceiver */
    USB_PDD_Disable1msInterrupt(USB0_BASE_PTR);            /* Disable "1ms" interrupt */
    USB_PDD_SetErrorInterruptMask(USB0_BASE_PTR, 0x00U);   /* Disable all "Error" interrupts */
    USB_PDD_SetUsbInterruptMask(USB0_BASE_PTR, 0x00U);     /* Disable all "Usb" interrupts */
    USB1_UsbUnlock(DevDataPtr);
  }
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  USB1_HostGetPortState (component USB_LDD)
*/
/*!
**     @brief
**         Returns port <state>.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @return
**                         - Returned value:
**                           LDD_USB_HOST_DISABLED - Host mode is
**                           disabled (by the user or by the clock
**                           configuration).
**                           LDD_USB_HOST_DISABLED_BY_OTG - Host mode is
**                           disabled by the OTG driver.
**                           LDD_USB_HOST_PORT_POWERED_OFF - Port is
**                           powered-off.
**                           LDD_USB_HOST_PORT_DISCONNECTED -  No device
**                           is connected.
**                           LDD_USB_HOST_PORT_DISABLED - Device is
**                           connected to the port.
**                           LDD_USB_HOST_PORT_RESETING - Port generates
**                           reset signaling.
**                           LDD_USB_HOST_PORT_RESET_RECOVERING - Port
**                           waits 10 ms for reset recovery.
**                           LDD_USB_HOST_PORT_ENABLED - Device is
**                           connected, reset and ready to use.
**                           LDD_USB_HOST_PORT_SUSPENDED - Port is
**                           suspended.
**                           LDD_USB_HOST_PORT_RESUME_READY - Port is
**                           ready to generate resume signaling.
**                           LDD_USB_HOST_PORT_RESUMING - Port generates
**                           resume signaling.
**                           LDD_USB_HOST_PORT_RESUME_RECOVERING - Port
**                           waits 10 ms for resume recovery.
*/
/* ===================================================================*/
LDD_USB_Host_TState USB1_HostGetPortState(LDD_TDeviceData *DeviceDataPtr)
{
  return (((USB1_TDeviceData*)DeviceDataPtr)->HostState);
}

/*
** ===================================================================
**     Method      :  USB1_HostSetPortState (component USB_LDD)
*/
/*!
**     @brief
**         This method sets root port (bus) states. Supported commands
**         are:
**         [LDD_USB_HOST_PORT_CMD_POWER_OFF]
**         Deactivates VBUS enable signal and sets the port to the
**         POWER_OFF state, closes all pipes and discards all pending
**         transfers.
**         [LDD_USB_HOST_PORT_CMD_POWER_ON]
**         Activates VBUS enable signal and sets the port to the
**         DISCONNECTED state.
**         Port must be in the POWERED_OFF state to be power on.
**         [LDD_USB_HOST_PORT_CMD_RESET]
**         Sets the port to the RESETING state, starts the reset
**         signaling and closes all pipes and discards all pending
**         transfers. As soon as the reset interval is elapsed the
**         reset signaling will be stopped, the port state will be
**         change to the RESET_RECOVERING, and the reset recovery
**         interval will begin. After the reset recovery interval is
**         elapsed, the port state will be changed to the ENABLED state.
**         In the ENABLED state the port can used to transfer data.
**         Device must be connected (ports state > DISCONNECTED) before
**         reset can be started.
**         [LDD_USB_HOST_PORT_CMD_DISABLE]
**         Sets the port to the DISABLED state and closes all pipes and
**         discards all pending transfers. This state can be changed
**         only by performing the bus reset(transfer to the ENABLED
**         state), by disconnecting the device (transfer to the
**         DISCONNECT state) or by the powering-off the bus (transfer
**         to the POWERED_OFF state).
**         [LDD_USB_HOST_PORT_CMD_SUSPEND]
**         Suspends port (state = SUSPENDED). No transaction should be
**         pending before this method is called.
**         Port must be in the LDD_USB_HOST_PORT_ENABLED state to be
**         suspend.
**         [LDD_USB_HOST_PORT_CMD_RESUME]
**         Sets the port to the RESUMING state and starts the resume
**         signaling. After the resume interval is elapsed, the port
**         state will be changed to the ENABLED state. In the ENABLED
**         state the port can used to transfer data.
**         Port must be in the LDD_USB_HOST_PORT_RESUME_READY state
**         before resume can start.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         Cmd             - Command
**     @return
**                         - Return value: ERR_OK - OK
**                           ERR_SPEED - The component does not work in
**                           the active clock configuration.
**                           ERR_DISABLED - The component is disabled.
**                           ERR_PARAM_COMMAND - Unknown command.
**                           ERR_USB_HOST_XXX where XXX is name of the
**                           state - Requested operation cannot be is
**                           done in current <state>.
*/
/* ===================================================================*/
LDD_TError USB1_HostSetPortState(LDD_TDeviceData *DeviceDataPtr, LDD_USB_Host_TPortControlCmd Cmd)
{
  USB1_TDeviceData                *DevDataPtr = (USB1_TDeviceData*)DeviceDataPtr;
  LDD_TError                       Res = (LDD_TError)DevDataPtr->HostState;

  /* Enable test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!DevDataPtr->EnUser) {           /* Is the device disabled by user? */
    return ERR_DISABLED;               /* If yes then error */
  }
  USB1_UsbLock(DevDataPtr);
  if ((uint32_t)DevDataPtr->HostState < (uint32_t)LDD_USB_HOST_PORT_POWERED_OFF) { /* */
    Res = (LDD_TError)DevDataPtr->HostState;
    USB1_UsbUnlock(DevDataPtr);
    return Res;
  }

  if (DevDataPtr->HostState >= LDD_USB_HOST_PORT_POWERED_OFF) { /* Is host enabled? */
    switch (Cmd) {
      case LDD_USB_HOST_PORT_CMD_POWER_OFF:
        /* Deactivates VBUS enable signal, sets the port to the POWER_OFF state */
        /* closes all pipes and discards all pending transfers. */
        DevDataPtr->HostState = LDD_USB_HOST_PORT_POWERED_OFF; /* Remember new state */
        USB1_HostCloseAllPipesAndDiscardAlltransfers(DevDataPtr);
        Res = ERR_OK;
        break;
      case LDD_USB_HOST_PORT_CMD_POWER_ON:
        /* Activates VBUS enable signal and sets the port to the DISCONNECTED state. */
        if (DevDataPtr->HostState == LDD_USB_HOST_PORT_POWERED_OFF) { /* Is port powered-off? */
          DevDataPtr->HostState = LDD_USB_HOST_PORT_DISCONNECTED; /* Remember new state */
          Res = ERR_OK;
        }
        break;
      case LDD_USB_HOST_PORT_CMD_RESET:
        /* See description of the HostResetPort() method */
        if (DevDataPtr->HostState > LDD_USB_HOST_PORT_DISCONNECTED) { /* Is a device connected? */
          USB1_HostResetPort(DevDataPtr);                  /* Yes, start reset signaling */
          Res = ERR_OK;
        }
        break;
      case LDD_USB_HOST_PORT_CMD_DISABLE:
        /* See description of the DisablePort() method */
        USB1_HostDisabledPort(DevDataPtr);                 /* Disable port */
        Res = ERR_OK;
        break;
      case LDD_USB_HOST_PORT_CMD_SUSPEND:
        if (DevDataPtr->HostState == LDD_USB_HOST_PORT_ENABLED) { /* Is a device enabled? */
          /* See description of the HostResumePort() method */
          USB1_HostSuspendPort(DevDataPtr);                /* Yes, suspend device */
          Res = ERR_OK;
        }
        break;
      case LDD_USB_HOST_PORT_CMD_RESUME:
        if (DevDataPtr->HostState == LDD_USB_HOST_PORT_RESUME_READY) { /* Is the device suspended at least 3 ms? */
          /* See description of the HostResumePort() method */
          USB1_HostResumePort(DevDataPtr);                 /* Yes, start resume signaling */
          Res = ERR_OK;
        }
        break;
      default:
        Res = ERR_PARAM_COMMAND;                           /* Unknown command */
        break;
    }
  }
  USB1_UsbUnlock(DevDataPtr);
  return(Res);
}

/*
** ===================================================================
**     Method      :  USB1_HostOpenPipe (component USB_LDD)
*/
/*!
**     @brief
**         Initializes pipe according to the values in the endpoint
**         descriptor and in the flags parameter. Allocate bandwidth
**         for periodic transfer types.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         PipeInitParamsPtr - Pointer to the
**                           structure containing pipe configuration
**                           data.
**     @param
**         PipeHandlePtr   - Pointer to pipe handle
**                           variable.
**     @return
**                         - Return value:
**                           ERR_DISABLED - Device is disabled.
**                           ERR_PARAM_ID - Requested transfer is not
**                           supported by the HW .
**                           ERR_OVERFLOW - Not enough frame time for
**                           periodic transfer type.
**                           ERR_OK - OK
*/
/* ===================================================================*/
LDD_TError USB1_HostOpenPipe(LDD_TDeviceData *DeviceDataPtr, LDD_USB_Host_TPipeDescr *PipeInitParamsPtr, LDD_USB_Host_TPipeHandle **PipeHandlePtr)
{
  USB1_TDeviceData                 *DevDataPtr = (USB1_TDeviceData*)DeviceDataPtr;
  USB1_TPipeDescr                  *PipePtr;
  LDD_TError                        Res = ERR_OVERFLOW;
  uint32_t                          x;

  /* Enable test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!DevDataPtr->EnUser) {           /* Is the device disabled by user? */
    return ERR_DISABLED;               /* If yes then error */
  }
  *PipeHandlePtr = NULL;                                   /* Suppose bad params */
  USB1_UsbLock(DevDataPtr);
  if (DevDataPtr->HostState != LDD_USB_HOST_PORT_ENABLED) { /* Port enabled? */
    Res = (LDD_TError)DevDataPtr->HostState;               /* No, remember error code */
  } else {
    for (x = 0x00U; x < MAX_PIPES; x++) {                  /* Try to find empty pipe descriptor */
      PipePtr = &DevDataPtr->PDT[x];                       /* Get pipe descriptor */
      if (PipePtr->PipeState == USB1_PIPE_CLOSED) {        /* Free descriptor found? */
        Res = ERR_OK;                                      /* Yes, stop the loop */
        break;
      }
    }
    if (Res == ERR_OK) {                                   /* Empty pipe descriptor found? */
      if (DevDataPtr->BusSpeed == LDD_USB_FULL_SPEED) {    /* Compute SOF threshold */
        x = ((((0x65U + ((uint32_t)PipeInitParamsPtr->MaxPacketSize * 0x08U)) * 0x07U) / 0x06U) / 0x08U);
      } else {
        x = (((0x65U + ((uint32_t)PipeInitParamsPtr->MaxPacketSize * 0x08U)) * 0x07U) / 0x06U);
      }
      if (DevDataPtr->SofThresholdValue < x) {             /* New threshold greater then current value? */
        DevDataPtr->SofThresholdValue = (uint8_t)x;        /* Yes, remember and set new threshold value */
        USB_PDD_SetSofTresholdReg(USB0_BASE_PTR, DevDataPtr->SofThresholdValue);
      }
      switch (PipeInitParamsPtr->TransferType) {
        case LDD_USB_CONTROL:                              /* Control pipe? */
          /* Add the pipe to the BEGIN of the async. pipe list */
          if (DevDataPtr->AsyncPipeListTailPtr == NULL) {  /* Async. list empty? */
            DevDataPtr->AsyncPipeListTailPtr = PipePtr;    /* The new pipe is also last pipe in the list */
          }
          PipePtr->NextPipePtr = DevDataPtr->AsyncPipeListHeadPtr; /* Add the pipe to the begin of the async. pipe list */
          DevDataPtr->AsyncPipeListHeadPtr = PipePtr;      /* Update head list address */
          PipePtr->EpCtrlRegVal = 0x4DU;                   /* Remember value for EP control register */
          break;
        case LDD_USB_BULK:                                 /* Interrupt pipe? */
          /* Add the pipe to the END of the async. pipe list */
          if (DevDataPtr->AsyncPipeListTailPtr == NULL) {  /* Async. list empty? */
            DevDataPtr->AsyncPipeListHeadPtr = PipePtr;    /* The new pipe is also first pipe in the list */
          } else {
            DevDataPtr->AsyncPipeListTailPtr->NextPipePtr = PipePtr;
          }
          DevDataPtr->AsyncPipeListTailPtr = PipePtr;      /* Update tail pointer */
          PipePtr->NextPipePtr = NULL;                     /* This is the last pipe in the list */
          PipePtr->EpCtrlRegVal = 0x5DU;                   /* Remember value for EP control register */
          break;
        default:
          Res = ERR_PARAM_ID;
          break;
      }
      if (Res == ERR_OK) {                                 /* Empty pipe descriptor found? */
        PipePtr->Head = *PipeInitParamsPtr;                /* Yes, copy pipe setting */
        PipePtr->PipeState = USB1_PIPE_IDLE;               /* Set pipe state */
        PipePtr->ActiveTrPtr = NULL;                       /* Initialize Activ transfer pointer */
        PipePtr->LastTrPtr = NULL;                         /* Initialize Last transfer pointer */
        *PipeHandlePtr = PipePtr;                          /* Set pipe local data address as handle */
        PipePtr->NextData01 = (uint8_t)0x00U;              /* Set DATA0 as default DATA PID */
        if (DevDataPtr->BusSpeed == LDD_USB_LOW_SPEED) {   /* Directly connected Low speed device(without hub)? */
          PipePtr->Head.DevAddress |= (uint8_t)0x80U;      /* Transaction to this EP must be performed all low-speed */
          PipePtr->EpCtrlRegVal |= (uint8_t)0x80U;         /* Disable PRE_PID */
        } else if (PipePtr->Head.DevSpeed == LDD_USB_LOW_SPEED) { /* Low speed device after a hub? */
          PipePtr->Head.DevAddress |= (uint8_t)0x80U;      /* Transaction to this EP must be performed all low-speed */
        } else {
        }
      }
    }
  }
  USB1_UsbUnlock(DevDataPtr);
  return Res;
}

/*
** ===================================================================
**     Method      :  USB1_HostClosePipe (component USB_LDD)
*/
/*!
**     @brief
**         Deinitializes EP and disables it in the HW. For control EP
**         both directions are deinitialized. All pending transfers are
**         aborted and callback functions are called, if enabled.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         PipeHandlePtr   - Pipe handle
**     @return
**                         - Return value:
**                           ERR_DISABLED - Device is disabled.
**                           ERR_OK - OK
*/
/* ===================================================================*/
LDD_TError USB1_HostClosePipe(LDD_TDeviceData *DeviceDataPtr, LDD_USB_Host_TPipeHandle *PipeHandlePtr)
{
  USB1_TDeviceData                 *DevDataPtr = (USB1_TDeviceData*)DeviceDataPtr;
  USB1_TPipeDescr                  *PipePtr = (USB1_TPipeDescr*)PipeHandlePtr;
  USB1_TPipeDescr                  *LeftPipePtr,*tmpPipePtr;
  uint32_t                          x,y;
  LDD_TError                        Res;

  /* Enable test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!DevDataPtr->EnUser) {           /* Is the device disabled by user? */
    return ERR_DISABLED;               /* If yes then error */
  }
  USB1_UsbLock(DevDataPtr);
  if ((uint32_t)DevDataPtr->HostState < (uint32_t)LDD_USB_HOST_PORT_POWERED_OFF) { /* */
    Res = (LDD_TError)DevDataPtr->HostState;
    USB1_UsbUnlock(DevDataPtr);
    return Res;
  }
  if (PipePtr->PipeState != USB1_PIPE_CLOSED) {            /* Pipe opened? */
    LeftPipePtr = NULL;
    DevDataPtr->SofThresholdValue = 0U;                    /* Reset SOF threshold variable value */
    for (x = 0x00U; x < MAX_PIPES; x++) {                  /* Find ascendant pipe and compute new SOF threshold value */
      tmpPipePtr = &DevDataPtr->PDT[x];
      if (tmpPipePtr->PipeState != USB1_PIPE_CLOSED) {     /* Pipe opened? */
        if (tmpPipePtr != PipePtr) {
          if (DevDataPtr->BusSpeed == LDD_USB_FULL_SPEED) { /* Compute SOF threshold */
            y = ((((0x65U + ((uint32_t)tmpPipePtr->Head.MaxPacketSize * 0x08U)) * 0x07U) / 0x06U) / 0x08U);
          } else {
            y = (((0x65U + ((uint32_t)tmpPipePtr->Head.MaxPacketSize * 0x08U)) * 0x07U) / 0x06U);
          }
          if (DevDataPtr->SofThresholdValue < y) {         /* New threshold greater then current value? */
            DevDataPtr->SofThresholdValue = (uint8_t)y;    /* Yes, remember and set new threshold value */
          }
        }
      }
      if (tmpPipePtr->NextPipePtr == PipePtr) {            /* Ascendant pipe found? */
        tmpPipePtr->NextPipePtr = PipePtr->NextPipePtr;    /* Update its' pointer to the next item */
        LeftPipePtr = tmpPipePtr;
        break;
      }
    }
    USB_PDD_SetSofTresholdReg(USB0_BASE_PTR, DevDataPtr->SofThresholdValue); /* Set new SOF threshold value? */
    if (DevDataPtr->AsyncPipeListHeadPtr == PipePtr) {     /* Is the pipe on the head of async. pipe list */
      DevDataPtr->AsyncPipeListHeadPtr = PipePtr->NextPipePtr; /* remove it from the list head */
    }
    if (DevDataPtr->AsyncPipeListTailPtr == PipePtr) {
      DevDataPtr->AsyncPipeListTailPtr = LeftPipePtr;
    }
    USB1_HostQueueFlush(DevDataPtr, PipePtr, USB1_TRANSFER_ERROR_CANCELLED);
    PipePtr->PipeState = USB1_PIPE_CLOSED;                 /* Set pipe state */
  }
  USB1_UsbUnlock(DevDataPtr);
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  USB1_HostSendSetup (component USB_LDD)
*/
/*!
**     @brief
**         This method prepares control transfer. All transfer phases
**         are handled by this method.
**         Note: On some MCUs (e.g. Kinetis) must be the address of the
**         data buffer 4 bytes aligned.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         PipeHandlePtr   - Pipe handle.
**     @param
**         TransferDescriptorPtr -
**                           Pointer to transfer descriptor.
**     @param
**         TransferHandlePtr - Pointer to
**                           transfer handle variable.
**     @return
**                         - Return value: ERR_OK - OK
**                           ERR_SPEED - The component does not work in
**                           the active clock configuration.
**                           ERR_DISABLED - The component is disabled.
**                           ERR_PARAM_ADDRESS - Transfer descriptor
**                           pointer or Pipe descriptor pointer is NULL.
**                           ERR_PARAM_DATA - Pointer to the Setup data
**                           packet is NULL.
**                           ERR_FAILED - Pipe is closed.
**                           ERR_USB_HOST_XXX where XXX is name of the
**                           state - Port is not in enabled <state>.
*/
/* ===================================================================*/
LDD_TError USB1_HostSendSetup(LDD_TDeviceData *DeviceDataPtr, LDD_USB_Host_TPipeHandle *PipeHandlePtr, LDD_USB_Host_TTD *TransferDescriptorPtr, LDD_USB_Host_TTransferHandle **TransferHandlePtr)
{
  return HostQueueTransfer(DeviceDataPtr, PipeHandlePtr, TransferDescriptorPtr, TransferHandlePtr, LDD_USB_DIR_UNKNOWN);
}

/*
** ===================================================================
**     Method      :  USB1_HostSendData (component USB_LDD)
*/
/*!
**     @brief
**         This method prepares data to be sent to the device.
**         Note: On some MCUs (e.g. Kinetis) must be the address of the
**         data buffer 4 bytes aligned.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         PipeHandlePtr   - Pipe handle.
**     @param
**         TransferDescriptorPtr -
**                           Pointer to transfer descriptor.
**     @param
**         TransferHandlePtr - Pointer to
**                           transfer handle variable.
**     @return
**                         - Return value: ERR_OK - OK
**                           ERR_SPEED - The component does not work in
**                           the active clock configuration.
**                           ERR_DISABLED - The component is disabled.
**                           ERR_PARAM_ADDRESS - Transfer descriptor
**                           pointer or Pipe handle is NULL.
**                           ERR_FAILED - Pipe is closed.
**                           ERR_USB_HOST_XXX where XXX is name of the
**                           state - Port is not in enabled <state>.
*/
/* ===================================================================*/
LDD_TError USB1_HostSendData(LDD_TDeviceData *DeviceDataPtr, LDD_USB_Host_TPipeHandle *PipeHandlePtr, LDD_USB_Host_TTD *TransferDescriptorPtr, LDD_USB_Host_TTransferHandle **TransferHandlePtr)
{
  return HostQueueTransfer(DeviceDataPtr, PipeHandlePtr, TransferDescriptorPtr, TransferHandlePtr, LDD_USB_DIR_OUT);
}

/*
** ===================================================================
**     Method      :  USB1_HostRecvData (component USB_LDD)
*/
/*!
**     @brief
**         This method prepares buffer for data sent by the device.
**         Note: On some MCUs (e.g. Kinetis) must be the address of the
**         data buffer 4 bytes aligned.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         PipeHandlePtr   - Pipe handle.
**     @param
**         TransferDescriptorPtr -
**                           Pointer to transfer descriptor.
**     @param
**         TransferHandlePtr - Pointer to
**                           transfer handle variable.
**     @return
**                         - Return value: ERR_OK - OK
**                           ERR_SPEED - The component does not work in
**                           the active clock configuration.
**                           ERR_DISABLED - The component is disabled.
**                           ERR_PARAM_ADDRESS - Transfer descriptor
**                           pointer or Pipe handle is NULL.
**                           ERR_FAILED - Pipe is closed.
**                           ERR_USB_HOST_XXX where XXX is name of the
**                           state - Port is not in enabled <state>.
*/
/* ===================================================================*/
LDD_TError USB1_HostRecvData(LDD_TDeviceData *DeviceDataPtr, LDD_USB_Host_TPipeHandle *PipeHandlePtr, LDD_USB_Host_TTD *TransferDescriptorPtr, LDD_USB_Host_TTransferHandle **TransferHandlePtr)
{
  return HostQueueTransfer(DeviceDataPtr, PipeHandlePtr, TransferDescriptorPtr, TransferHandlePtr, LDD_USB_DIR_IN);
}

/*
** ===================================================================
**     Method      :  USB1_HostCancelTransfer (component USB_LDD)
*/
/*!
**     @brief
**         This method cancels all pending transfer requests in the
**         given EP queue. Callback function is called ( if enabled)
**         for each cancelled transfer request.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         PipeHandlePtr   - Pipe handle
**     @return
**                         - Return value: ERR_OK - OK
**                           ERR_SPEED - The component does not work in
**                           the active clock configuration.
**                           ERR_DISABLED - The component is disabled.
**                           ERR_PARAM_ADDRESS - Transfer descriptor
**                           pointer or Pipe handle is NULL.
**                           ERR_FAILED - Pipe is closed.
**                           ERR_USB_HOST_XXX where XXX is name of the
**                           state - Port is not in enabled <state>.
*/
/* ===================================================================*/
LDD_TError USB1_HostCancelTransfer(LDD_TDeviceData *DeviceDataPtr, LDD_USB_Host_TPipeDescr *PipeHandlePtr)
{
  USB1_TDeviceData                 *DevDataPtr = (USB1_TDeviceData*)DeviceDataPtr;
  USB1_TPipeDescr                  *PipePtr = (USB1_TPipeDescr*)(void*)PipeHandlePtr;
  LDD_TError                        Res;

  /* Enable test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!DevDataPtr->EnUser) {           /* Is the device disabled by user? */
    return ERR_DISABLED;               /* If yes then error */
  }
  /* Input parameter test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  if (PipePtr == NULL) {
    return ERR_PARAM_ADDRESS;
  }
  USB1_UsbLock(DevDataPtr);
  if (PipePtr->PipeState == USB1_PIPE_CLOSED) {            /* Pipe closed? */
    USB1_UsbUnlock(DevDataPtr);
    return ERR_FAILED;                                     /* Yes, return with error */
  }
  if (DevDataPtr->HostState != LDD_USB_HOST_PORT_ENABLED) { /* Port enabled? */
    Res = (LDD_TError)DevDataPtr->HostState;               /* Yes, return with error */
  } else {
    USB1_HostQueueFlush(DevDataPtr, PipePtr, USB1_TRANSFER_ERROR_CANCELLED);
    Res = ERR_OK;                                          /* return with error */
  }
  USB1_UsbUnlock(DevDataPtr);
  return Res;
}

/*
** ===================================================================
**     Method      :  USB1_HostGetAsyncTransactionReadyPipe (component USB_LDD)
**
**     Description :
**         Returns pointer to the periodic pipe that has transaction 
**         ready for this frame.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static USB1_TPipeDescr* USB1_HostGetAsyncTransactionReadyPipe(USB1_TDeviceData *DevDataPtr, USB1_TPipeDescr *PipePtr)
{
  USB1_TPipeDescr                 *NextPipePtr;

  if (USB_PDD_GetTokenBusyFlag(USB0_BASE_PTR)) {
    return NULL;
  }

  if (PipePtr == NULL) {                                   /* Last pipe in the async. pipe list? */
    PipePtr = DevDataPtr->AsyncPipeListHeadPtr;            /* Yes, start from the begin of the async. list */
  }
  NextPipePtr = PipePtr;
  do {
    NextPipePtr = NextPipePtr->NextPipePtr;
    if (NextPipePtr == NULL) {                             /* Last pipe in the async. pipe list? */
      NextPipePtr = DevDataPtr->AsyncPipeListHeadPtr;      /* Yes, start from the begin of the async. list */
    }
    if (NextPipePtr == PipePtr) {                          /* Ready pipe found? */
      return NULL;                                         /* No, return NULL */
    }
    if (NextPipePtr->ActiveTrPtr != NULL) {                /* Transfer pending on selected pipe? */
      break;                                               /* Return address of this pipe */
    }
  } while (1);
  return NextPipePtr;
}

/*
** ===================================================================
**     Method      :  USB1_HostMainIsr (component USB_LDD)
**
**     Description :
**         Host mode main interrupt handler.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB1_HostMainIsr(USB1_TDeviceData *DevDataPtr, uint32_t IntStatus, uint32_t Status, uint32_t ErrorStatus)
{
  uint32_t                         BDCtrlReg;
  uint16_t                         DataSize;
  USB1_TBD                        *BDPtr;
  USB1_TPipeDescr                 *PipePtr;
  USB1_TTrDescr                   *TrPtr;

  if ((IntStatus & USB_PDD_TOK_DNE_INT) == 0x00U) {
    /* Some special interrupt detected */
    if ((IntStatus & USB_PDD_USB_RST_INT) != 0x00U) {       /* USB Deattach Signal detected? */
      /* (2,5us of SE0) */
      /* USB deattach signal detected interrupt handler */
      if ((IntStatus & USB_PDD_ATTACH_INT) == 0x00U) {
        /* Sets the port to the DISCONNECTED state and closes all pipes and discards all pending transfers. */
        /*  This state can be changed only by performing the bus reset(transfer to the ENABLED state), */
        /*  by the disconnecting the device (transfer to the DISCONNECT state) or by the powering-off */
        /* the bus (transfer to the POWERED_OFF state). */
        DevDataPtr->HostState = LDD_USB_HOST_PORT_DISCONNECTED; /* Set new state */
        USB_PDD_EnableSof(USB0_BASE_PTR, PDD_DISABLE);      /* Disable SOF */
        USB_PDD_EnableDirectLowSpeedDevice(USB0_BASE_PTR, PDD_DISABLE); /* This is necessary to correctly detect device speed */
        USB_PDD_EnableLowSpeed(USB0_BASE_PTR, PDD_DISABLE); /* This is necessary to correctly detect device speed */
        USB_PDD_ClearUsbInterruptFlags(USB0_BASE_PTR,USB_PDD_ATTACH_INT); /* Clear "attach" interrupt flag */
        USB_PDD_SetUsbInterruptMask(USB0_BASE_PTR,USB_PDD_ATTACH_INT); /* Enable only "attach" interrupt */
        USB1_HostCloseAllPipesAndDiscardAlltransfers(DevDataPtr);
        USB1_OnHostDeviceDeattach(DevDataPtr->UserHostDataPtr);
      } else {
      }
    } else if ((IntStatus & USB_PDD_ATTACH_INT) != 0x00U) { /* Attach signal detected? */
      /* Attach signal detected interrupt handler */
      /* (2,5 us without transition and bus state != SE0 */
      if (!USB_PDD_GetSE0(USB0_BASE_PTR)) {
        /* Enables port. Disables all USB interrupts except "deattach" interrupt */
        /* and starts 100 ms debounce interval. After this interval is done it */
        /* starts the reset signaling(50 ms). After reset signaling is done it */
        /* checks the connected device speed and adds 10ms of reset recovery. As */
        /* soon as the reset recovery interval is done the port state is changed */
        /* to the "ENABLED" state and port can be used to transmit data. Called */
        /* from ISR if the "connect" event is detected. */
        DevDataPtr->HostState = LDD_USB_HOST_PORT_DISABLED; /* Set new port state */
        USB_PDD_SuspendTransceiver(USB0_BASE_PTR, PDD_DISABLE); /* Wake-up transceiver */
        USB_PDD_ClearUsbInterruptFlags(USB0_BASE_PTR,USB_PDD_USB_RST_INT); /* Clear "deattach" interrupt flag */
        USB_PDD_SetUsbInterruptMask(USB0_BASE_PTR,USB_PDD_USB_RST_INT); /* Enable only "deattach" interrupt */
        USB1_StartTimer(DevDataPtr, USB1_HOST_DEBOUNCE_INTERVAL_MS + 1); /* Wait at least 100 ms before reseting the device */
      } else {
        ;
      }
    } else if ((IntStatus & USB_PDD_RESUME_INT) != 0x00U) { /* Resume received? */
      /* Resume signal interrupt handler */
      USB1_HostResumePort(DevDataPtr);
    } else {
      ;
    }
  } else {
    /* Only TOKE_DONE interrupt detected (no other interrupt signal active) */
    PipePtr = DevDataPtr->ActivePipePtr;
    DevDataPtr->ActivePipePtr = NULL;
    DevDataPtr->ActivePipePtr = USB1_HostGetAsyncTransactionReadyPipe(DevDataPtr, PipePtr);
    if (DevDataPtr->ActivePipePtr != NULL) {               /* Transaction ready? */
      USB1_HostStartTransaction(DevDataPtr);               /* Start transaction on selected pipe */
    }
    /* Handle the last transaction */
    TrPtr     = PipePtr->ActiveTrPtr;
    if (TrPtr == NULL) {
      return;
    }
    BDPtr = &DevDataPtr->BDT[Status >> 0x02];
    BDCtrlReg = BDPtr->CtrlReg;
    if ((ErrorStatus & ~(uint32_t)(USB_PDD_BTO_ERR_INT | USB_PDD_DMA_ERR_INT)) != 0x00U) {
      TrPtr->ErrorCounter--;                               /* Decrement error counter */
      if (!TrPtr->ErrorCounter) {
        if ((ErrorStatus & USB_PDD_BTS_ERR_INT) != 0x00U) {
          TrPtr->TrState = USB1_TRANSFER_ERROR_BTS;
        } else if ((ErrorStatus & USB_PDD_PID_ERR_INT) != 0x00U) {
          TrPtr->TrState = USB1_TRANSFER_ERROR_PID;
        } else if ((ErrorStatus & USB_PDD_CRC5_EOF_INT) != 0x00U) {
          TrPtr->TrState = USB1_TRANSFER_ERROR_EOF;
        } else if ((ErrorStatus & USB_PDD_CRC16_INT) != 0x00U) {
          TrPtr->TrState = USB1_TRANSFER_ERROR_CRC16;
        } else if ((ErrorStatus & USB_PDD_DFN8_INT) != 0x00U) {
          TrPtr->TrState = USB1_TRANSFER_ERROR_DFN8;
        } else {
          ;
        }
      }
    } else {
      switch ((uint32_t)BDCtrlReg & USB1_BD_PID_MASK) {
        case USB1_BD_PID_ACK:                              /* Setup/OUT(Tx) packet sent and ACK packet received  */
        case USB1_BD_PID_DATA0:                            /* IN(Rx) packet received and ACK sent*/
        case USB1_BD_PID_DATA1:
          TrPtr->ErrorCounter = 0x03U;
          switch (TrPtr->TrState) {                        /* Check transfer state */
            case USB1_TRANSFER_SETUP_PENDING:              /* Control transfer setup stage done? */
              /* Setup stage of control transfer done */
              if (TrPtr->Head.BufferSize == 0x00U) {       /* Any data stage? */
                TrPtr->TrState = USB1_TRANSFER_HSK_QUEUED; /* No data stage, next phase is handshake phase */
                PipePtr->Head.EpDir = (uint8_t)(1U);       /* Handshake packet must IN direction */
              } else {
                TrPtr->TrState = USB1_TRANSFER_DATA_QUEUED; /* Next phase is data phase */
              }
              PipePtr->NextData01 = (uint8_t)USB1_BD_DATA1; /* Next data packet must has DATA1 PID */
              break;
            case USB1_TRANSFER_DATA_PENDING:               /* Data transaction done? */
              /* Data transaction done */                  /* Toggle DATA PID */
              PipePtr->NextData01 ^= (uint8_t)USB1_BD_DATA1;
              DataSize  = (uint16_t)((BDCtrlReg >> 0x10U) & 0x03FFU); /* Get transferred data size */
              TrPtr->Head.BufferSize -= DataSize;          /* Update remaining data counter */
              TrPtr->tmpBufferPtr = (uint8_t*)((uint32_t)TrPtr->tmpBufferPtr + (uint32_t)DataSize); /* Update data pointer */
              if ((TrPtr->Head.BufferSize == 0x00U) || (DataSize < PipePtr->Head.MaxPacketSize)) { /* All data transferred? */
                /* Transfer done */
                if (PipePtr->Head.TransferType == LDD_USB_CONTROL) { /* Control transfer? */
                  TrPtr->TrState = USB1_TRANSFER_HSK_QUEUED; /* Next phase is handshake phase */
                  TrPtr->Head.BufferSize = 0x00U;          /* Handshake packet must be 0 size */
                  PipePtr->NextData01 = (uint8_t)USB1_BD_DATA1; /* Handshake data packet must has DATA1 PID */
                  PipePtr->Head.EpDir = (uint8_t)(PipePtr->Head.EpDir ^ LDD_USB_DIR_MASK); /* Handshake packet must has opposite direction to data packet */
                } else {
                  TrPtr->TrState = USB1_TRANSFER_DONE;     /* Update transfer state */
                }
              } else {
                /* Next transaction needed */
              }
              break;
            case USB1_TRANSFER_HSK_PENDING:                /* Control transfer handshake stage done? */
              /* Control transfer done */
              TrPtr->TrState = USB1_TRANSFER_DONE;         /* Update transfer state */
              break;
            default:
              break;
          }
          break;
        case USB1_BD_PID_NACK:
          break;
        case USB1_BD_PID_STALL:
          TrPtr->TrState = USB1_TRANSFER_ERROR_STALLED;
          TrPtr->ErrorCounter = 0x00U;
          break;
        default:                                           /* Transfer error */
          TrPtr->ErrorCounter--;                           /* Decrement error counter */
          if (!TrPtr->ErrorCounter) {
            switch ((uint32_t)BDCtrlReg & USB1_BD_PID_MASK) {
              case USB1_BD_PID_BUS_TIMEOUT: /*  */
                TrPtr->TrState = USB1_TRANSFER_ERROR_BUS_TIMEOUT;
                break;
              case USB1_BD_PID_DATA_ERROR:
                TrPtr->TrState = USB1_TRANSFER_ERROR_DATA;
                break;
              default:
                break;
            }
          }
        break;
      }
    }
    if (TrPtr->TrState < USB1_TRANSFER_QUEUED) {           /* Transfer done, stalled, canceled or error detected? */
      USB1_HostTransferDone(DevDataPtr, PipePtr);          /* Call transfer complete handler */
      if (TrPtr->TrState != USB1_TRANSFER_DONE) {          /* Transfer error? */
        while (PipePtr->ActiveTrPtr) {                     /* For all TDs in pipe's queue do: */
          PipePtr->ActiveTrPtr->TrState = USB1_TRANSFER_ERROR; /* Set requested transfer state */
          USB1_HostTransferDone(DevDataPtr, PipePtr);      /* Call transfer complete handler */
        }
      }
    }
    if (DevDataPtr->ActivePipePtr == NULL) {               /* Transaction in progress? */
      if (PipePtr->ActiveTrPtr != NULL) {                  /* No, transaction ready for current pipe ? */
        if (PipePtr->PipeState != USB1_PIPE_CANCEL_PENDING) {
          DevDataPtr->ActivePipePtr = PipePtr;
          USB1_HostStartTransaction(DevDataPtr);           /* Start new transaction on current pipe */
        }
      } else {
      }
    }
  }
}

/*
** ===================================================================
**     Method      :  USB1_HostTimerDoneIsr (component USB_LDD)
**
**     Description :
**         Host mode timer done handler.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB1_HostTimerDoneIsr(USB1_TDeviceData *DevDataPtr)
{
  switch (DevDataPtr->HostState) {
    case LDD_USB_HOST_PORT_DISABLED:
      /* Device is attached for at least 100 ms (TATTDB). Usb spec 2.0 chapter 7.17.3 */
      switch (USB_PDD_GetBusSpeed(USB0_BASE_PTR)) {
        case USB_PDD_LOW_SPEED:
          DevDataPtr->BusSpeed = LDD_USB_LOW_SPEED;
          USB_PDD_EnableDirectLowSpeedDevice(USB0_BASE_PTR, PDD_ENABLE);
          USB_PDD_EnableLowSpeed(USB0_BASE_PTR, PDD_ENABLE);
          break;
        case USB_PDD_FULL_SPEED:
          DevDataPtr->BusSpeed = LDD_USB_FULL_SPEED;
          USB_PDD_EnableLowSpeed(USB0_BASE_PTR, PDD_DISABLE);
          break;
        default:
          DevDataPtr->BusSpeed = LDD_USB_SPEED_UNKNOWN;
          return;
      }
      USB1_HostResetPort(DevDataPtr);
      break;
    case LDD_USB_HOST_PORT_RESETING:
      /* Reset signal was asserted for at 50 ms least ms (TDRST). Usb spec 2.0 chapter 7.17.3 */
      USB_PDD_StartResetSignaling(USB0_BASE_PTR, PDD_DISABLE); /* Stop reset signaling */
      USB_PDD_ClearUsbInterruptFlags(USB0_BASE_PTR,USB_PDD_ALL_INT_FLAGS); /* Clear all interrupt flags */
      USB_PDD_EnableBusResetInterrupt(USB0_BASE_PTR);       /* Enable only "deattach" interrupt */
      USB_PDD_EnableSof(USB0_BASE_PTR, PDD_ENABLE);         /* and enable SOF */
      /* Wait at least 10 ms (TRSTRCY) for reset recovery */
      DevDataPtr->HostState = LDD_USB_HOST_PORT_RESET_RECOVERING; /* Remember new port state */
      USB1_StartTimer(DevDataPtr, USB1_HOST_RESET_RECOVERY_INTERVAL_MS + 1); /* Start reset recovery interval */
      break;
    case LDD_USB_HOST_PORT_RESET_RECOVERING:
      /* Reset recovery done, the port can now be used to transfer data */
      DevDataPtr->HostState = LDD_USB_HOST_PORT_ENABLED;    /* Remember new port state */
      USB1_OnHostResetRecovery(DevDataPtr->UserHostDataPtr, DevDataPtr->BusSpeed);
      break;
    case LDD_USB_HOST_PORT_SUSPENDED:
      USB_PDD_ClearUsbInterruptFlags(USB0_BASE_PTR,USB_PDD_USB_RST_INT); /* Clear "deattache" interrupt flag */
      USB_PDD_SetUsbInterruptMask(USB0_BASE_PTR,USB_PDD_USB_RST_INT | USB_PDD_RESUME_INT); /* Enable "deattach" and "resume" interrupts */
      DevDataPtr->HostState = LDD_USB_HOST_PORT_RESUME_READY; /* Remember new port state */
      break;
    case LDD_USB_HOST_PORT_RESUMING:
      if (USB_PDD_GetResumeSignalState(USB0_BASE_PTR)) {
        USB_PDD_StartResumeSignaling(USB0_BASE_PTR, PDD_DISABLE); /* Stop resume signaling */
        USB1_StartTimer(DevDataPtr, 1);                     /* and wait 1 ms before enabling SOF */
      } else {
        USB_PDD_EnableSof(USB0_BASE_PTR, PDD_ENABLE);       /* Enable SOF */
        DevDataPtr->HostState = LDD_USB_HOST_PORT_RESUME_RECOVERING; /* Remember new port state */
        USB1_StartTimer(DevDataPtr, USB1_HOST_RESUME_RECOVERY_INTERVAL_MS + 1); /* Start resume recovery interval */
      }
      break;
    case LDD_USB_HOST_PORT_RESUME_RECOVERING:
      DevDataPtr->HostState = LDD_USB_HOST_PORT_ENABLED;    /* Remember new port state */
      USB1_OnHostResumeRecovery(DevDataPtr->UserHostDataPtr);
      break;
    default:
      break;
  }
}
/*
** ===================================================================
**     Method      :  USB1_HostIsr (component USB_LDD)
**
**     Description :
**         Host interrupt service handler.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB1_HostIsr(USB1_TDeviceData *DevDataPtr, uint32_t InSignalsState)
{
  uint32_t                         ErrorStatus;
  uint32_t                         IntStatus;
  uint32_t                         TransactionStatus;

  if (DevDataPtr->HostState >= LDD_USB_HOST_PORT_POWERED_OFF) {
    /* 1ms interrupt handler */
    if ((InSignalsState & USB1_TIMEOUT) != 0x00U) {         /* Timeout? */
      USB1_HostTimerDoneIsr(DevDataPtr);
    }
    IntStatus = USB_PDD_GetUsbInterruptFlags(USB0_BASE_PTR);
    IntStatus &= USB_PDD_GetUsbInterruptMask(USB0_BASE_PTR);
    if (IntStatus) {                                       /* Any interrupt request? */
      TransactionStatus = USB_PDD_ReadStatusReg(USB0_BASE_PTR); /* Read Status register before clearing int. flags */
      ErrorStatus = USB_PDD_GetErrorsInterruptFlags(USB0_BASE_PTR); /* Read Error status register */
      if ((IntStatus & USB_PDD_TOK_DNE_INT) != 0x00U) {    /* TokenDone request? */
        USB_PDD_ClearErrorsInterruptFlags(USB0_BASE_PTR, (uint8_t)ErrorStatus); /* Clear error flags */
      }
      USB_PDD_ClearUsbInterruptFlags(USB0_BASE_PTR, (uint8_t)IntStatus); /* Clear interrupt flags */
      USB1_HostMainIsr(DevDataPtr, IntStatus, TransactionStatus, ErrorStatus); /* Call interrupt handler */
    }
  }
}

/*
** ===================================================================
**     Method      :  USB1_USB_Interrupt (component USB_LDD)
**
**     Description :
**         USB interrupt handler
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(USB1_USB_Interrupt)
{
  /* {Default RTOS Adapter} ISR parameter is passed through the global variable */
  USB1_TDeviceDataPtr DevDataPtr = INT_USB0__DEFAULT_RTOS_ISRPARAM;
  uint32_t NewInSignalState;
  uint32_t OtgIntStatus;
  
  DevDataPtr->ISR = TRUE;
  OtgIntStatus = USB_PDD_GetOtgInterruptFlags(USB0_BASE_PTR);
  OtgIntStatus &= USB_PDD_GetOtgInterruptMask(USB0_BASE_PTR);
  USB_PDD_ClearOtgInterruptFlags(USB0_BASE_PTR, OtgIntStatus);
  NewInSignalState = DevDataPtr->InSignalsState;           /* Get current signal state */
  if ((OtgIntStatus & USB_PDD_1_MSEC_INT) != 0U) {         /* 1ms timer interrupt? */
    NewInSignalState |= USB1_1MS_TIMEOUT;                  /* Remember timeout */
    if (DevDataPtr->msCounter > 0x00) {                    /* Otg timing in progress? */
      DevDataPtr->msCounter--;                             /* Decrement 1 ms counter */
      if (DevDataPtr->msCounter == 0x00 ) {                /* Timing done? */
        NewInSignalState |= USB1_TIMEOUT;                  /* Remember timeout */
        USB_PDD_Disable1msInterrupt(USB0_BASE_PTR);         /* No, disable 1 ms interrupt */
      }
    }
  } /* 1 ms interrupt */
  USB1_HostIsr(DevDataPtr, NewInSignalState);              /* Call interrupt handler */
  DevDataPtr->ISR = FALSE;
}


/* END USB1. */

/*!
** @}
*/
/*
** ###################################################################
**
**     This file was created by Processor Expert 10.3 [05.09]
**     for the Freescale Kinetis series of microcontrollers.
**
** ###################################################################
*/
